{"./":{"url":"./","title":"介绍","keywords":"","body":" 面试题目仓库 目前本仓库正在整理上传Java相关面试题目，题目正在逐步添加中... 题目在线查看：https://edu2act.github.io/interview/ 当前题目数量： Java基础 [12] JDBC [0] Jsp&Servlet [0] Hibernate [0] Mybatis [0] Spring [29] EJB [0] WebService [0] 设计模式 [0] 数据结构 [0] 其它 [0] 声明：本仓库部分图片、文章来源于网络，版权归原作者所有，如有侵权，请与我联系删除。 "},"core_java/grammar/p001.html":{"url":"core_java/grammar/p001.html","title":"面向对象的三大特性","keywords":"","body":"面向对象的三大特性 封装 每个对象包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来进行自己的操作。将方法、属性、字段包装在类中，通过实例化类来生成对象。 封装就像建房子，类就是房子，属性是门窗，字段是房子里的东西，方法是人的行为。属性对字段有保护作用，防止字段被随意的修改或读取。 好的封装能减少耦合 类内部的实现可以自由修改 类具有清晰的对外接口 继承 继承代表一种is-a关系（子类is父类），是面向对象程序设计能够提高软件开发效率的重要原因之一。子类具有（继承）父类的所有特性，也可以定义自己独有的特性。 子类具有父类非private的属性和方法 子类可以扩展父类没有的属性和方法 子类可以重写父类的方法 继承是具有传递性的 继承来的属性和方法是隐式的 缺点：子类和父类具有强耦合性 多态 多态表示不同的对象可以执行相同的动作，但要通过他们自己的实现代码来执行。比如猫和狗继承自动物，猫叫和狗叫都是相同的动作-动物叫，但是实现方式不同。 子类可以以父类的身份出现 （使用父类对象的地方都可以用子类来代替） 子类在工作时以自己的方式来实现 子类以父类的身份出现时，子类特有的方法和属性不能使用 多态的作用是消除类型之间的耦合关系 多态就是对象拥有多种形态：引用多态和方法多态 引用多态：父类的引用可以指向本类对象、父类的引用可以指向子类的对象 方法多态：创建本类对象时，调用的方法为本类的方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法 存在多态的必要条件：继承、重写、向上转型 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 在Java中有两种形式可以实现多态。继承和接口 基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。 "},"core_java/grammar/p002.html":{"url":"core_java/grammar/p002.html","title":"面向对象的四大特征","keywords":"","body":"面向对象的四大特征 抽象 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象,二是数据抽象。 继承 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象,这些对象通过一个受保护的接口访问其他对象。 多态性 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 "},"core_java/grammar/p003.html":{"url":"core_java/grammar/p003.html","title":"面向对象的六大原则","keywords":"","body":"面向对象的六大原则 单一职责原则——SRP 开闭原则——OCP 里式替换原则——LSP 依赖倒置原则——DIP 接口隔离原则——ISP 迪米特原则——LOD 单一职责原则SRP(Single Responsibility Principle) 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。 单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。 单一职责原则的好处如下： 可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多 提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。 开放封闭原则OCP(Open－Close Principle) 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。 开闭原则和单一职责原则一样，是非常基础而且一般是常识的原则。开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。 当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。 这个准则和单一职责原则一样，是一个大家都这样去认为但是又没规定具体该如何去做的一种原则。 开闭原则我们可以用一种方式来确保他，我们用抽象去构建框架，用实现扩展细节。这样当发生修改的时候，我们就直接用抽象了派生一个具体类去实现修改。 里式替换原则LSP(the Liskov Substitution Principle LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。 里氏替换原则是一个非常有用的一个概念。他的定义 如果对每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有对象o1都替换成o2的时候，程序P的行为都没有发生变化，那么类型T2是类型T1的子类型。 这样说有点复杂，其实有一个简单的定义 所有引用基类的地方必须能够透明地使用其子类的对象。 里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类可以增加自己独有的方法。 当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。 里氏替换原则之所以这样要求是因为继承有很多缺点，他虽然是复用代码的一种方法，但同时继承在一定程度上违反了封装。父类的属性和方法对子类都是透明的，子类可以随意修改父类的成员。这也导致了，如果需求变更，子类对父类的方法进行一些复写的时候，其他的子类无法正常工作。所以里氏替换法则被提出来。 确保程序遵循里氏替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，然后用实现去扩展细节，这个是不是很耳熟，对，里氏替换原则和开闭原则往往是相互依存的。 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。 依赖倒置原则指的是一种特殊的解耦方式，使得高层次的模块不应该依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。 这也是一个让人难懂的定义，他可以简单来说就是： 高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 在Java 中抽象指的是接口或者抽象类，两者皆不能实例化。而细节就是实现类，也就是实现了接口或者继承了抽象类的类。他是可以被实例化的。高层模块指的是调用端，底层模块是具体的实现类。在Java中，依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的。这就是俗称的面向接口编程。 我们下面有一个例子来讲述这个问题。这个例子是工人用锤子来修理东西。我们的代码如下： public class Hammer { public String function(){ return \"用锤子修理东西\"; } } public class Worker { public void fix(Hammer hammer){ System.out.println(\"工人\" + hammer.function()); } public static void main(String[] args) { new Worker().fix(new Hammer()); } } 这个是一个很简单的例子，但是如果我们要新增加一个功能，工人用 螺丝刀来修理东西，在这个类，我们发现是很难做的。因为我们Worker类依赖于一个具体的实现类Hammer。所以我们用到面向接口编程的思想，改成如下的代码： public interface Tools { public String function(); } 然后我们的Worker是通过这个接口来于其他细节类进行依赖。代码如下： public class Worker { public void fix(Tools tool){ System.out.println(\"工人\" + tool.function()); } public static void main(String[] args) { new Worker().fix(new Hammer()); new Worker().fix(new Screwdriver()); } } 我们的Hammer类与Screwdriver类实现这个接口 public class Hammer implements Tools{ public String function(){ return \"用锤子修理东西\"; } } public class Screwdriver implements Tools{ @Override public String function() { return \"用螺丝刀修理东西\"; } } 这样，通过面向接口编程，我们的代码就有了很高的扩展性，降低了代码之间的耦合度，提高了系统的稳定性。 接口分离原则ISP(the Interface Segregation Principle ISP) 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来 接口隔离原则的定义是 客户端不应该依赖他不需要的接口 换一种说法就是类间的依赖关系应该建立在最小的接口上。这样说好像更难懂。我们通过一个例子来说明。我们知道在Java中一个具体类实现了一个接口，那必然就要实现接口中的所有方法。如果我们有一个类A和类B通过接口I来依赖，类B是对类A依赖的实现，这个接口I有5个方法。但是类A与类B只通过方法1,2,3依赖，然后类C与类D通过接口I来依赖，类D是对类C依赖的实现但是他们却是通过方法1,4,5依赖。那么是必在实现接口的时候，类B就要有实现他不需要的方法4和方法5 而类D就要实现他不需要的方法2，和方法3。这简直就是一个灾难的设计。 所以我们需要对接口进行拆分，就是把接口分成满足依赖关系的最小接口，类B与类D不需要去实现与他们无关接口方法。比如在这个例子中，我们可以把接口拆成3个，第一个是仅仅由方法1的接口，第二个接口是包含2,3方法的，第三个接口是包含4,5方法的。 这样，我们的设计就满足了接口隔离原则。 以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。 迪米特原则LOD(the Law of Demeter LOD) 迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。他的定义： 一个对象应该对其他对象保持最小的了解。 因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。 迪米特法则还有一个更简单的定义 只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 这里我们可以用一个现实生活中的例子来讲解一下。比如我们需要一张CD,我们可能去音像店去问老板有没有我们需要的那张CD，老板说现在没有，等有的时候你们来拿就行了。在这里我们不需要关心老板是从哪里，怎么获得的那张CD，我们只和老板（直接朋友）沟通，至于老板从他的朋友那里通过何种条件得到的CD，我们不关心，我们不和老板的朋友（陌生人）进行通信，这个就是迪米特的一个应用。说白了，就是一种中介的方式。我们通过老板这个中介来和真正提供CD的人发生联系。 总结 到这里，面向对象的六大原则，就写完了。我们看出来，这些原则其实都是应对不断改变的需求。每当需求变化的时候，我们利用这些原则来使我们的代码改动量最小，而且所造成的影响也是最小的。但是我们在看这些原则的时候，我们会发现很多原则并没有提供一种公式化的结论，而即使提供了公式化的结论的原则也只是建议去这样做。这是因为，这些设计原则本来就是从很多实际的代码中提取出来的，他是一个经验化的结论。怎么去用它，用好他，就要依靠设计者的经验。否则一味者去使用设计原则可能会使代码出现过度设计的情况。大多数的原则都是通过提取出抽象和接口来实现，如果发生过度的设计，就会出现很多抽象类和接口，增加了系统的复杂度。让本来很小的项目变得很庞大，当然这也是Java的特性（任何的小项目都会做成中型的项目）。 "},"core_java/grammar/p004.html":{"url":"core_java/grammar/p004.html","title":"什么是低耦合高内聚","keywords":"","body":"什么是低耦合高内聚 耦合 简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 有软硬件之间的耦合，还有软件各模块之间的耦合。 耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 耦合可以分为以下几种，它们之间的耦合度由高到低排列如下： 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。 标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合 内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 "},"core_java/grammar/p005.html":{"url":"core_java/grammar/p005.html","title":"Java中的作用域的区别","keywords":"","body":"Java中的作用域的区别 Java中的作用域有 public 、protected、private、default。 public：它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类，接口等，它往往用于对象或类对外的一种接口的形式。 protected：它主要的作用是用来保护子类，它的含义在于子类可以用它修饰的成员，其他的不可以，他相对于传递给子类的一种继承的东西。 private：它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是private修饰符，它不希望被外部类访问。 default：有时候也成为friendly（友元），它是针对本包访问而设计的，任何处于本包下的类，接口，异常等，都可以访问，即使是父类没有用protected修饰的成员也可以。 类内部 本包 子类 外部包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 从上面可以更直观的看到： public：可以被其他所有类访问 protected：可以被自身，子类，以及同一包下的类访问 default：可以被自身和同一包中的类访问 private：只可以被自身访问 "},"core_java/grammar/p006.html":{"url":"core_java/grammar/p006.html","title":"重载(Overload)与重写(Override)的区别","keywords":"","body":"重写(Override)与重载(Overload)的区别 方法的重写和重载是Java 多态性的不同表现。 重写Overriding 是父类与子类之间多态性的一种表现，重载Overloading 是一个类中多态性的一种表现。 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move(); // 执行 Animal 类的方法 b.move(); // 执行 Dog 类的方法 } } 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 在上面的例子中可以看到，尽管b属于Animal类型，但是它运行的是Dog类的move方法。 这是由于在编译阶段，只是检查参数的引用类型。然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。 因此在上面的例子中，之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。 思考以下例子： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } public void bark(){ System.out.println(\"狗可以吠叫\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move(); // 执行 Animal 类的方法 b.move(); // 执行 Dog 类的方法 b.bark(); } } 以上实例编译运行结果如下： TestDog.java:30: cannot find symbol symbol : method bark() location: class Animal b.bark(); ^ 该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。 方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super关键字的使用 当需要在子类中调用父类的被重写方法时，要使用super关键字。 class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal b = new Dog(); // Dog 对象 b.move(); // 执行 Dog类的方法 } } 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 重载(Overload) 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 public class Overloading { public int test(){ System.out.println(\"test1\"); return 1; } public void test(int a){ System.out.println(\"test2\"); } // 以下两个参数类型顺序不同 public String test(int a,String s){ System.out.println(\"test3\"); return \"returntest3\"; } public String test(String s,int a){ System.out.println(\"test4\"); return \"returntest4\"; } public static void main(String[] args){ Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); } } 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写和重载是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 "},"core_java/grammar/p007.html":{"url":"core_java/grammar/p007.html","title":"String、StringBuffer、StringBuilder的区别","keywords":"","body":"String、StringBuffer、StringBuilder的区别 重新认识String类 深入理解String、StringBuffer、StringBuilder 不同场景下三个类的性能测试 常见的关于String、StringBuffer的面试题（辟谣网上流传的一些曲解String类的说法） 重新认识String类 想要了解一个类，最好的办法就是看这个类的实现源代码，String类的实现在\\jdk1.6.0_14\\src\\java\\lang\\String.java文件中。 打开这个类文件就会发现String类是被final修饰的： public final class String implements java.io.Serializable, Comparable, CharSequence { /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ...... } 从上面可以看出几点： String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。 上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。 下面再继续看String类的一些方法实现： public String substring(int beginIndex, int endIndex) { if (beginIndex count) { throw new StringIndexOutOfBoundsException(endIndex); } if (beginIndex > endIndex) { throw new StringIndexOutOfBoundsException(endIndex - beginIndex); } return ((beginIndex == 0) && (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value); } public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf); } public String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = count; int i = -1; char[] val = value; /* avoid getfield opcode */ int off = offset; /* avoid getfield opcode */ while (++i 从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点： 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。 在了解了于String类基础的知识后，下面来看一些在平常使用中容易忽略和混淆的地方。 深入理解String、StringBuffer、StringBuilder String str=\"hello world\"和String str=new String(\"hello world\")的区别 想必大家对上面2个语句都不陌生，在平时写代码的过程中也经常遇到，那么它们到底有什么区别和联系呢？下面先看几个例子： public class Main { public static void main(String[] args) { String str1 = \"hello world\"; String str2 = new String(\"hello world\"); String str3 = \"hello world\"; String str4 = new String(\"hello world\"); System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str2==str4); } } 这段代码的输出结果为： false true false 为什么会出现这样的结果？下面解释一下原因： 在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。 因此在上述代码中， String str1 = \"hello world\"; 和 String str3 = \"hello world\"; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量\"hello world\"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。 众所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。 String、StringBuffer以及StringBuilder的区别 既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？ 那么看下面这段代码： public class Main { public static void main(String[] args) { String string = \"\"; for(int i=0;i 这句 string += \"hello\"; 的过程相当于将原有的string变量指向的对象内容取出与\"hello\"作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了： 从这段反编译出的字节码文件可以很清楚地看出：从第8行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。从上面还可以看出：string+=\"hello\" 的操作事实上会自动被JVM优化成： StringBuilder str = new StringBuilder(string); str.append(\"hello\"); str.toString(); 再看下面这段代码： public class Main { public static void main(String[] args) { StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i 反编译字节码文件得到： 从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。 那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的，也就是说StringBuffer是线程安全的。 下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现： StringBuilder的insert方法 public StringBuilder insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } StringBuffer的insert方法 public synchronized StringBuffer insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } 不同场景下三个类的性能测试 这一小节我们来做个小测试，来测试一下三个类的性能区别： public class Main { private static int time = 50000; public static void main(String[] args) { testString(); testStringBuffer(); testStringBuilder(); test1String(); test2String(); } public static void testString () { String s=\"\"; long begin = System.currentTimeMillis(); for(int i=0; i 测试结果（Win7，Eclipse，JDK6）： 操作java.lang.String类型使用的时间为：8090毫秒 操作java.lang.StringBuffer类型使用的时间为：3毫秒 操作java.lang.StringBuilder类型使用的时间为：2毫秒 字符串直接相加操作：1毫秒 字符串间接相加操作：9毫秒 上面提到 string+=\"hello\" 的操作事实上会自动被JVM优化，看下面这段代码： public class Main { private static int time = 50000; public static void main(String[] args) { testString(); testOptimalString(); } public static void testString () { String s=\"\"; long begin = System.currentTimeMillis(); for(int i=0; i 执行结果： 操作java.lang.String类型使用的时间为：8654毫秒 模拟JVM优化操作的时间为：8651毫秒 得到验证。 下面对上面的执行结果进行一般性的解释： 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如 \"I\"+\"love\"+\"java\"; 的字符串相加，在编译期间便被优化成了\"Ilovejava\"。这个可以用javap -c命令反编译生成的class文件进行验证。对于间接相加（即包含字符串引用），形如 s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 String、StringBuilder、StringBuffer三者的执行效率： StringBuilder > StringBuffer > String 当然这个是相对的，不一定在所有情况下都是这样。 比如 String str = \"hello\"+ \"world\" 的效率就比 StringBuilder st = new StringBuilder().append(\"hello\").append(\"world\") 要高。 因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\" 这种形式； 当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 常见的关于String、StringBuffer的面试题 下面是一些常见的关于String、StringBuffer的一些面试笔试题，若有不正之处，请谅解和批评指正。 下面这段代码的输出结果是什么？ String a = \"hello2\"; String b = \"hello\" + 2; System.out.println((a == b)); 输出结果为：true。原因很简单，\"hello\"+2在编译期间就已经被优化成\"hello2\"，因此在运行期间，变量a和变量b指向的是同一个对象。 下面这段代码的输出结果是什么？ String a = \"hello2\"; String b = \"hello\"; String c = b + 2; System.out.println((a == c)); 输出结果为:false。由于有符号引用的存在，所以 String c = b + 2; 不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。 下面这段代码的输出结果是什么？ String a = \"hello2\"; final String b = \"hello\"; String c = b + 2; System.out.println((a == c)); 输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么 String c = b + 2; 在编译期间就会被优化成：String c = \"hello\" + 2;。 下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { String a = \"hello2\"; final String b = getHello(); String c = b + 2; System.out.println((a == c)); } public static String getHello() { return \"hello\"; } } 输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。 下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { String a = \"hello\"; String b = new String(\"hello\"); String c = new String(\"hello\"); String d = b.intern(); System.out.println(a==b); System.out.println(b==c); System.out.println(b==d); System.out.println(a==d); } } false false false true 这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在Java se6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。 String str = new String(\"abc\")创建了多少个对象？ 这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。 首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容： 很显然，new只调用了一次，也就是说只创建了一个对象。 而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了\"abc\"对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个\"abc\"对象，而在代码执行过程中确实只创建了一个String对象。 因此，这个问题如果换成 String str = new String(\"abc\") 涉及到几个String对象？合理的解释是2个。 个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚是这段代码执行过程中创建了多少个对象还是涉及到多少个对象再根据具体的来进行回答。 下面这段代码[1]和[2]的区别是什么？ public class Main { public static void main(String[] args) { String str1 = \"I\"; // str1 += \"love\"+\"java\"; // [1] str1 = str1+\"love\"+\"java\"; // [2] } } [1]的效率比[2]的效率要高，[1]中的 \"love\"+\"java\" 在编译期间会被优化成 \"lovejava\"，而[2]中的不会被优化。下面是两种方式的字节码： [1]的字节码 [2]的字节码 可以看出，在[1]中只进行了一次append操作，而在[2]中进行了两次append操作。 "},"core_java/grammar/p008.html":{"url":"core_java/grammar/p008.html","title":"类加载与初始化","keywords":"","body":"类加载与初始化 类加载器 在了解Java的机制之前，需要先了解类在JVM（Java虚拟机）中是如何加载的，这对后面理解java其它机制将有重要作用。 每个类编译后产生一个Class对象，存储在.class文件中，JVM使用类加载器（Class Loader）来加载类的字节码文件（.class），类加载器实质上是一条类加载器链，一般的，我们只会用到一个原生的类加载器，它只加载Java API等可信类，通常只是在本地磁盘中加载，这些类一般就够我们使用了。如果我们需要从远程网络或数据库中下载.class字节码文件，那就需要我们来挂载额外的类加载器。 一般来说，类加载器是按照树形的层次结构组织的，每个加载器都有一个父类加载器。另外，每个类加载器都支持代理模式，即可以自己完成Java类的加载工作，也可以代理给其它类加载器。 类加载器的加载顺序有两种，一种是父类优先策略，一种是是自己优先策略，父类优先策略是比较一般的情况（如JDK采用的就是这种方式），在这种策略下，类在加载某个Java类之前，会尝试代理给其父类加载器，只有当父类加载器找不到时，才尝试自己去加载。自己优先的策略与父类优先相反，它会首先尝试子经济加载，找不到的时候才要父类加载器去加载，这种在web容器（如tomcat）中比较常见。 动态加载 不管使用什么样的类加载器，类，都是在第一次被用到时，动态加载到JVM的。这句话有两层含义： Java程序在运行时并不一定被完整加载，只有当发现该类还没有加载时，才去本地或远程查找类的.class文件并验证和加载； 当程序创建了第一个对类的静态成员的引用（如类的静态变量、静态方法、构造方法——构造方法也是静态的）时，才会加载该类。Java的这个特性叫做：动态加载。 需要区分加载和初始化的区别，加载了一个类的.class文件，不以为着该Class对象被初始化，事实上，一个类的初始化包括3个步骤： 加载（Loading），由类加载器执行，查找字节码，并创建一个Class对象（只是创建）； 链接（Linking），验证字节码，为静态域分配存储空间（只是分配，并不初始化该存储空间），解析该类创建所需要的对其它类的应用； 初始化（Initialization），首先执行静态初始化块static{}，初始化静态变量，执行静态方法（如构造方法）。 链接 Java在加载了类之后，需要进行链接的步骤，链接简单地说，就是将已经加载的java二进制代码组合到JVM运行状态中去。它包括3个步骤： 验证（Verification），验证是保证二进制字节码在结构上的正确性，具体来说，工作包括检测类型正确性，接入属性正确性（public、private），检查final class 没有被继承，检查静态变量的正确性等。 准备（Preparation），准备阶段主要是创建静态域，分配空间，给这些域设默认值，需要注意的是两点：一个是在准备阶段不会执行任何代码，仅仅是设置默认值，二个是这些默认值是这样分配的，原生类型全部设为0，如：float:0f,int 0, long 0L, boolean:0（布尔类型也是0），其它引用类型为null。 解析（Resolution），解析的过程就是对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址），并保证这些类被正确的找到。解析的过程可能导致其它的类被加载。需要注意的是，根据不同的解析策略，这一步不一定是必须的，有些解析策略在解析时递归的把所有引用解析，这是early resolution，要求所有引用都必须存在；还有一种策略是late resolution，这也是Oracle 的JDK所采取的策略，即在类只是被引用了，还没有被真正用到时，并不进行解析，只有当真正用到了，才去加载和解析这个类。 初始化 注意：在《Java编程思想》中，说static{}子句是在类第一次加载时执行且执行一次（可能是笔误或翻译错误，因为此书的例子显示static是在第 一次初始化时执行的），《Java深度历险》中说 static{}是在第一次实例化时执行且执行一次，这两种应该都是错误的，static{}是在第一次初始化时执行，且只执行一次；用下面的代码可以判 定出来： public class Toy { private String name; public static final int price=10; static { System.out.println(\"Initializing\"); } Toy() { System.out.println(\"Building\"); } Toy(String name) { this.setName(name); } public static String playToy(String player) { String msg = buildMsg(player); System.out.println(msg); return msg; } private String buildMsg(String player) { String msg = player + \" plays \" + name; return msg; } } // 对上面的类，执行下面的代码： Class c = Class.forName(\"myblog.rtti.Toy\"); // c.newInstance(); 可以看到，不实例化，只执行forName初始化时，仍然会执行static{}子句，但不执行构造方法，因此输出的只有Initializing，没有Building。 根据java虚拟机规范，所有java虚拟机实现必须在每个类或接口被java程序首次主动使用时才初始化。 主动使用有以下6种： 创建类的实例 访问某个类或者接口的静态变量，或者对该静态变量赋值（如果访问静态编译时常量(即编译时可以确定值的常量)不会导致类的初始化） 调用类的静态方法 反射（Class.forName(xxx.xxx.xxx)） 初始化一个类的子类（相当于对父类的主动使用），不过直接通过子类引用父类元素，不会引起子类的初始化（参见示例6） Java虚拟机被标明为启动类的类（包含main方法的） 类与接口的初始化不同，如果一个类被初始化，则其父类或父接口也会被初始化，但如果一个接口初始化，则不会引起其父接口的初始化。 示例 通过上面的讲解，将可以理解下面的程序 （下面的程序部分来自于《Java编程思想》）： class Toy { static { // 静态子句，只在类第一次被加载并初始化时执行一次，而且只执行一次 System.out.println(\"Initializing\"); } Toy() { // 构造方法，在每次声明新对象时加载 System.out.println(\"Building\"); } } 对上面的程序段，第一次调用Class.forName(\"Toy\")，将执行static子句；如果在之后执行new Toy()都只执行构造方法。 需要注意newInstance()方法 Class cc = Class.forName(\"Toy\");// 获得类（注意，需要使用含包名的全限定名） Toy toy=(Toy)cc.newInstance(); // 相当于new一个对象，但Gum类必须有默认构造方法（无参） 类字面常量 用类字面常量 .class和Class.forName都可以创建对类的应用，但是不同点在于，用Gum.class创建Class对象的应用时，不会自动初始化该Class对象（static子句不会执行） public class TestToy { public static void main(String[] args) { // try { // Class c = Class.forName(\"myblog.classloader.Toy\"); // } catch (ClassNotFoundException e) { // e.printStackTrace(); // } Class c = Toy.class; // 不会输出任何值 } } 使用Toy.class是在编译期执行的，因此在编译时必须已经有了Toy的.class文件，不然会编译失败，这与 Class.forName(\"myblog.classloader.Toy\")不同，后者是运行时动态加载。 但是，如果该main方法是直接写在Toy类中，那么调用Toy.class，会引起初始化，并输出Initializing，原因并不是Toy.class引起的，而是该类中含有启动方法main，该方法会导致Toy的初始化。 编译时常量 回到完整的类Toy，如果直接输出：System.out.println(Toy.price)，会发现static子句和构造方法都没有被执行，这是因为Toy中，常量price被static final限定，这样的常量叫做编译时常量，对于这种常量，不需要初始化就可以读取。 编译时常量必须满足3个条件：static的，final的，常量。 下面几种都不是编译时常量，对它们的应用，都会引起类的初始化： static int a; final int b; static final int c= ClassInitialization.rand.nextInt(100); static final int d; static { d=5; } static块的本质 注意下面的代码： class StaticBlock { static final int c = 3; static final int d; static int e = 5; static { d = 5; e = 10; System.out.println(\"Initializing\"); } StaticBlock() { System.out.println(\"Building\"); } } public class StaticBlockTest { public static void main(String[] args) { System.out.println(StaticBlock.c); System.out.println(StaticBlock.d); System.out.println(StaticBlock.e); } } 这段代码的输出是什么呢？Initialing在c、d、e之前输出，还是在之后？e输出的是5还是10？ 执行一下，结果为： 3 Initializing 5 10 答案是3最先输出，Intializing随后输出，e输出的是10，为什么呢？ 原因是这样的：输出c时，由于c是编译时常量，不会引起类初始化，因此直接输出，输出d时，d不是编译时常量，所以会引起初始化操作，即static块的执行，于是d被赋值为5，e被赋值为10，然后输出Initializing，之后输出d为5，e为10。 但e为什么是10呢？原来，JDK会自动为e的初始化创建一个static块，所以上面的代码等价于： class StaticBlock { static final int d; static int e; static { e=5; } static { d = 5; e = 10; System.out.println(\"Initializing\"); } StaticBlock() { System.out.println(\"Building\"); } } 可见，按顺序执行，e先被初始化为5，再被初始化为10，于是输出了10。 类似的，容易想到下面的代码： class StaticBlock { static { d = 5; e = 10; System.out.println(\"Initializing\"); } static final int d; static int e = 5; StaticBlock() { System.out.println(\"Building\"); } } 在这段代码中，对e的声明被放到static块后面，于是，e会先被初始化为10，再被初始化为5，所以这段代码中e会输出为5。 当访问一个Java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化 class B { static int value = 100; static { System.out.println(\"Class B is initialized\");// 输出 } } class A extends B { static { System.out.println(\"Class A is initialized\"); // 不输出 } } public class SuperClassTest { public static void main(String[] args) { System.out.println(A.value);// 输出100 } } 在该例子中，虽然通过A来引用了value，但value是在父类B中声明的，所以只会初始化B，而不会引起A的初始化 "},"core_java/grammar/p009.html":{"url":"core_java/grammar/p009.html","title":"RTTI和反射机制","keywords":"","body":"RTTI和反射机制 类加载器 并不是所有的Class都能在编译时明确，因此在某些情况下需要在运行时再发现和确定类型信息（比如：基于构建编程，），这就是RTTI（Runtime Type Information，运行时类型信息）。 在Java中，有两种RTTI的方式，一种是传统的，即假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。 在本文中，将共同使用下面的玩具类Toy，该类中定义了公有、私有方法，变量，构造方法，父类、父接口等： public interface IToy { public String playToy(String player) throws Exception; } public class AbstractToy implements IToy { @Override public String playToy(String player) throws Exception { System.out.println(player + \" plays abstract toy\"); return \"\"; } } public class Toy extends AbstractToy { private String name; public String color; protected int size; public static final int price = 10; static { System.out.println(\"Loading\"); } // 构造方法一定要声明为public类型，不然用getConstructors无法得到 public Toy() { System.out.println(\"Initialing\"); setName(\"myToy\"); color = \"red\"; size = 5; } public Toy(String name, String color, int size) { this.setName(name); this.color = color; this.size = size; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String playToy(String player) throws Exception { String msg = buildMsg(player); System.out.println(msg); return msg; } private String buildMsg(String player) { String msg = player + \" plays \" + name; return msg; } } 传统的RTTI 严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为RTTI指的是传统的RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能（超类会自动实例化为子类，或使用instance of）。 传统的RTTI有3种实现方式： 向上转型或向下转型（upcasting and downcasting），在java中，向下转型（父类转成子类）需要强制类型转换 Class对象（用了Class对象，不代表就是反射，如果只是用Class对象cast成指定的类，那就还是传统的RTTI） instanceof或isInstance() 传统的RTTI与反射最主要的区别，在于RTTI在编译期需要.class文件，而反射不需要。传统的RTTI使用转型或Instance形式实现，但都需要指定要转型的类型，比如： public void rtti(Object obj){ Toy toy = Toy(obj); // Toy toy = Class.forName(\"myblog.rtti.Toy\") // obj instanceof Toy } 注意其中的obj虽然是被转型了，但在编译期，就需要知道要转成的类型Toy，也就是需要Toy的.class文件。 相对的，反射完全在运行时在通过Class类来确定类型，不需要提前加载Toy的.class文件。 反射 那到底什么是反射（Reflection）呢？反射有时候也被称为内省（Introspection），事实上，反射，就是一种内省的方式，Java不允许在运行时改变程序结构或类型变量的结构，但它允许在运行时去探知、加载、调用在编译期完全未知的class，可以在运行时加载该class，生成实例对象（instance object），调用method，或对field赋值。这种类似于“看透”了class的特性被称为反射（Reflection），我们可以将反射直接理解为：可以看到自己在水中的倒影，这种操作与直接操作源代码效果相同，但灵活性高得多。 关于Java的反射API，没必要去记忆，可以在任何JDK API中查询即可： Class类：http://www.ostools.net/uploads/apidocs/jdk-zh/java/lang/Class.html reflect包：http://www.ostools.net/uploads/apidocs/jdk-zh/java/lang/reflect/package-summary.html 反射的实现方式 import java.lang.reflect.Array; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; public class ToyReflection { public static void printInfo(String info, Object obj) { if (obj.getClass().isArray()) { System.out.println(info + \": \"); int length = Array.getLength(obj); System.out.println(\"Array Size: \" + length); for (int i = 0; i c = Class.forName(\"myblog.rtti.Toy\"); printInfo(\"获得类对象\", c); // 获得超类 Class superClass = c.getSuperclass(); printInfo(\"获得超类\", superClass); // 获得所有父接口 Class[] interfaces = c.getInterfaces(); printInfo(\"获得所有父接口\", interfaces); // 实例化 Toy toy = (Toy) c.newInstance(); printInfo(\"实例化\", toy); // 获得访问属性为public的构造方法 Constructor[] constructors = c.getConstructors(); printInfo(\"获得构造方法\", constructors); // 获得指定参数的构造方法 Constructor constructor = c.getDeclaredConstructor(String.class, String.class, int.class); printInfo(\"获得指定构造方法\", constructor); // 获得方法，getMethod只能获得public方法，包括父类和接口继承的方法 Method method = c.getMethod(\"playToy\", String.class); printInfo(\"获得公有方法\", method); // 调用方法 method.invoke(toy, \"张三\"); // 获得修饰符，包括private/public/protect,static String modifier = Modifier.toString(method.getModifiers()); printInfo(\"获得修饰符\", modifier); // 获得参数类型 Class[] paramTypes = method.getParameterTypes(); printInfo(\"获得参数类型\", paramTypes); // 获得返回值类型 Class returnType = method.getReturnType(); printInfo(\"获得返回值类型\", returnType); // 获得异常类型 Class[] excepTypes = method.getExceptionTypes(); printInfo(\"获得异常类型\", excepTypes); // 调用私有方法，getDeclaredMethod获得类自身的方法，包括public,protect,private方法 Method method2 = c.getDeclaredMethod(\"buildMsg\", String.class); method2.setAccessible(true); String result = (String) method2.invoke(toy, \"李四\"); printInfo(\"获得私有方法\", result); // 获得全部属性 Field[] fields = c.getFields(); printInfo(\"获得全部属性\", fields); // 获得类自身定义的指定属性 Field field = c.getDeclaredField(\"name\"); printInfo(\"获得自身属性\", field); // 获得类及其父类，父接口定义的public属性 Field field2 = c.getField(\"color\"); printInfo(\"获得公有属性\", field2); // 获得权限修饰符，包括private/public/protect,static,final String fieldModifier = Modifier.toString(field.getModifiers()); printInfo(\"获得权限修饰符\", fieldModifier); // 操作数组 int[] exampleArray = { 1, 2, 3, 4, 5 }; // 获得数组类型 Class componentType = exampleArray.getClass().getComponentType(); printInfo(\"数组类型\", componentType.getName()); // 获得长度 printInfo(\"数组长度\", Array.getLength(exampleArray)); // 获得指定元素 printInfo(\"获得数组元素\", Array.get(exampleArray, 2)); // 修改指定元素 Array.set(exampleArray, 2, 6); printInfo(\"修改数组元素\", exampleArray); // 获得当前的类加载器 printInfo(\"获得当前类加载器\", toy.getClass().getClassLoader().getClass().getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } } 通过上面的代码，可以清晰的理解如何“在水中看到自己”，不过需要注意的有几点： 在java的反射机制中，getDeclaredMethod得到的是全部方法，getMethod得到的是公有方法； 反射机制的setAccessible可能会破坏封装性，可以任意访问私有方法和私有变量； setAccessible并不是将private改为public，事实上，public方法的accessible属性也是false的，setAccessible只是取消了安全访问控制检查，所以通过设置setAccessible，可以跳过访问控制检查，执行的效率也比较高。参考：提高Java反射速度 反射的性能 反射机制给予Java开发很大的灵活性，但反射机制本身也有缺点，代表性的缺陷就是反射的性能，一般来说，通过反射调用方法的效率比直接调用的效率要至少慢一倍以上。参考：反射性能测试 反射与设计模式 反射的一个很重要的作用，就是在设计模式中的应用，包括在工厂模式和代理模式中的应用。参考：反射使用实例详解 "},"core_java/grammar/p010.html":{"url":"core_java/grammar/p010.html","title":"提高Java反射速度","keywords":"","body":"提高Java反射速度 提高java反射速度的方法method.setAccessible(true) Java代码中，常常将一个类的成员变量置为private，在类的外面获取此类的私有成员变量的value时，需要注意: public class AccessibleTest { private int id; private String name; public AccessibleTest() {} public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Main { public static void main(String[] args) throws Exception { Class clazz = Class.forName(\"com.test.accessible.AccessibleTest\"); AccessibleTest at = new AccessibleTest(); at.setId(1); at.setName(\"AT\"); for (Field f : clazz.getDeclaredFields()) { // AccessibleTest类中的成员变量为private,故必须进行此操作 f.setAccessible(true); // 获取当前对象中当前Field的value System.out.println(f.get(at)); } } } 如果没有在获取Field之前调用setAccessible(true)方法，异常： java.lang.IllegalAccessException: Class com.test.accessible.Main can not access a member of class com.test.accessible.AccessibleTest with modifiers \"private\" 当然在AccessibleTest类的内部(AccessibleTest的内部类除外)，进行如上操作则不需要调用setAccesible()方法。 明显 Accessible并不是标识方法能否访问的。public的方法 Accessible仍为false，使用了method.setAccessible(true)后 性能有了20倍的提升，Accessable属性是继承自AccessibleObject 类。 功能是启用或禁用安全检查 JDK API中的解释 AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获得字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。 在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象。 setAccessible public void setAccessible(boolean flag) throws SecurityException 将此对象的 accessible 标志设置为指示的布尔值。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。 实际上setAccessible是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问。 "},"core_java/grammar/p011.html":{"url":"core_java/grammar/p011.html","title":"反射性能测试","keywords":"","body":"反射性能测试 通过对比静态调用与类反射调用方法的效率，来了解现代框架中大量应用的反射调用对性能的影响程度。以便在系统架构中对性能与开发便利性之间进行权衡与取舍。 代码： public class PerformanceTest { public static void main(String[] args) throws Exception { int testTime = 10000000; PerformanceTest test = new PerformanceTest(); String msg = \"this is test message\"; long bTime = System.currentTimeMillis(); for(int i=0; i 测试结果： 930 5369 898 5052 885 5346 889 4992 对比代码的测试结果，没有缓存被调用方法的情况下，性能损失更为严重。 而考虑在框架级实现中，缓存是通过map等机制进行的，那么在获取缓存时的时间成本也要计算在内，则整体性能对比将在上述两个测试之间。 考虑目前的计算机系统的速度，应用开发已经不在那么介意性能，而更为注重系统的可维护性和扩展性以及快速开发效率上。上述的测试结果是在一千万次的测试基础上产生的。而在通常的一次业务请求中，反射使用的次数应该是非常少的，只在框架级基础上被使用，在一个高负载的系统中，业务处理的性能将是关键点，而不在于使用的这些反射所带来的性能影响上。而使用反射所带来的开发便利与可维护性可扩展性的提升所带来的价值，是远远高于其所损耗的性能的。 又回想起原来在某个所谓高性能项目中通过减少反射来提高性能的做法，现在想来，比较愚蠢。这说明前期的测试工作没有到位，而带来这样的结论偏差，从而导致了开发与维护的不便，而且极大地影响了开发速度。 其实那个系统的大部分性能瓶颈都是在数据库上，大部分的业务处理都是在数据库中进行的，在项目后面的性能测试中发现，WEB服务器的负载非常低，远远低于数据库，大部分的操作都是在等待数据库的返回。 前期某些推论既没有经过验证，也没有相关的使用经验来支持此推论，是导致这种错误的根源。在将来的架构设计工作与框架选型要加强这方面的评估工作，来达到性能与开发效率间的最佳平衡。 "},"core_java/grammar/p012.html":{"url":"core_java/grammar/p012.html","title":"反射使用实例详解","keywords":"","body":"反射使用实例详解 本篇文章依旧采用小例子来说明，案例驱动是最好的，要不然只看理论的话，看了也不懂，不过建议大家在看完文章之后，在回过头去看看理论，会有更好的理解。 案例：通过一个对象获得完整的包名和类名 package Reflect; /** * 通过一个对象获得完整的包名和类名 * */ class Demo{ //other codes... } class hello{ public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.getClass().getName()); } } 运行结果： Reflect.Demo 所有类的对象其实都是Class的实例。 案例：实例化Class类对象 package Reflect; class Demo{ //other codes... } class hello{ public static void main(String[] args) { Class demo1=null; Class demo2=null; Class demo3=null; try{ // 一般尽量采用这种形式 demo1=Class.forName(\"Reflect.Demo\"); }catch(Exception e){ e.printStackTrace(); } demo2=new Demo().getClass(); demo3=Demo.class; System.out.println(\"类名称 \"+demo1.getName()); System.out.println(\"类名称 \"+demo2.getName()); System.out.println(\"类名称 \"+demo3.getName()); } } 运行结果： 类名称 Reflect.Demo 类名称 Reflect.Demo 类名称 Reflect.Demo 案例：通过Class实例化其他类的对象 通过无参构造实例化对象 package Reflect; class Person{ public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString(){ return \"[\"+this.name+\" \"+this.age+\"]\"; } private String name; private int age; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Person per=null; try { per=(Person)demo.newInstance(); } catch (InstantiationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } per.setName(\"Rollen\"); per.setAge(20); System.out.println(per); } } 运行结果： [Rollen 20] 但是注意一下，当我们把Person中的默认的无参构造函数取消的时候，比如自己定义只定义一个有参数的构造函数之后，会出现错误。 比如我定义了一个构造函数： public Person(String name, int age) { this.age=age; this.name=name; } 然后继续运行上面的程序，会出现： java.lang.InstantiationException: Reflect.Person at java.lang.Class.newInstance0(Class.java:340) at java.lang.Class.newInstance(Class.java:308) at Reflect.hello.main(hello.java:39) Exception in thread \"main\" java.lang.NullPointerException at Reflect.hello.main(hello.java:47) 所以在编写使用Class实例化其他类的对象的时候，一定要自己定义无参的构造函数。 案例：通过Class调用其它类中的构造函数 也可以通过这种方式通过Class创建其它类的对象。 package Reflect; import java.lang.reflect.Constructor; class Person{ public Person() {} public Person(String name){ this.name=name; } public Person(int age){ this.age=age; } public Person(String name, int age) { this.age=age; this.name=name; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString(){ return \"[\"+this.name+\" \"+this.age+\"]\"; } private String name; private int age; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Person per1=null; Person per2=null; Person per3=null; Person per4=null; // 取得全部的构造函数 Constructor cons[]=demo.getConstructors(); try{ per1=(Person)cons[0].newInstance(); per2=(Person)cons[1].newInstance(\"Rollen\"); per3=(Person)cons[2].newInstance(20); per4=(Person)cons[3].newInstance(\"Rollen\",20); }catch(Exception e){ e.printStackTrace(); } System.out.println(per1); System.out.println(per2); System.out.println(per3); System.out.println(per4); } } 运行结果： [null 0] [Rollen 0] [null 20] [Rollen 20] 案例：返回一个类实现的接口 package Reflect; interface China{ public static final String name=\"Rollen\"; public static int age=20; public void sayChina(); public void sayHello(String name, int age); } class Person implements China{ public Person() {} public Person(String sex){ this.sex=sex; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } @Override public void sayChina(){ System.out.println(\"hello ,china\"); } @Override public void sayHello(String name, int age){ System.out.println(name+\" \"+age); } private String sex; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } // 保存所有的接口 Class intes[]=demo.getInterfaces(); for (int i = 0; i 运行结果： 实现的接口 Reflect.China PS：以下几个例子，都会用到这个例子的Person类，所以为节省篇幅，此处不再粘贴Person的代码部分，只粘贴主类hello的代码。 案例：取得其它类中的父类 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } // 取得父类 Class temp=demo.getSuperclass(); System.out.println(\"继承的父类为： \"+temp.getName()); } } 运行结果： 继承的父类为： java.lang.Object 案例：获得其他类中的全部构造函数 这个例子需要在程序开头添加import java.lang.reflect.*; 然后将主类编写为： class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Constructorcons[]=demo.getConstructors(); for (int i = 0; i 运行结果： 构造方法： public Reflect.Person() 构造方法： public Reflect.Person(java.lang.String) 但是细心的话会发现，上面的构造函数没有public 或者private这一类的修饰符，下面这个例子就来获取修饰符。 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Constructorcons[]=demo.getConstructors(); for (int i = 0; i p[]=cons[i].getParameterTypes(); System.out.print(\"构造方法： \"); int mo=cons[i].getModifiers(); System.out.print(Modifier.toString(mo)+\" \"); System.out.print(cons[i].getName()); System.out.print(\"(\"); for(int j=0;j 运行结果： 构造方法： public Reflect.Person(){} 构造方法： public Reflect.Person(java.lang.String arg1){} 有时候一个方法可能还有异常。 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Method method[]=demo.getMethods(); for(int i=0;i returnType=method[i].getReturnType(); Class para[]=method[i].getParameterTypes(); int temp=method[i].getModifiers(); System.out.print(Modifier.toString(temp)+\" \"); System.out.print(returnType.getName()+\" \"); System.out.print(method[i].getName()+\" \"); System.out.print(\"(\"); for(int j=0;j exce[]=method[i].getExceptionTypes(); if(exce.length>0){ System.out.print(\") throws \"); for(int k=0;k 运行结果： public java.lang.String getSex () public void setSex (java.lang.String arg0) public void sayChina () public void sayHello (java.lang.String arg0,int arg1) public final native void wait (long arg0) throws java.lang.InterruptedException public final void wait () throws java.lang.InterruptedException public final void wait (long arg0,int arg1) throws java.lang.InterruptedException public boolean equals (java.lang.Object arg0) public java.lang.String toString () public native int hashCode () public final native java.lang.Class getClass () public final native void notify () public final native void notifyAll () 案例：取得其它类的全部属性 通过class取得一个类的全部框架 class hello { public static void main(String[] args) { Class demo = null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"===============本类属性========================\"); // 取得本类的全部属性 Field[] field = demo.getDeclaredFields(); for (int i = 0; i type = field[i].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + field[i].getName() + \";\"); } System.out.println(\"===============实现的接口或者父类的属性========================\"); // 取得实现的接口或者父类的属性 Field[] filed1 = demo.getFields(); for (int j = 0; j type = filed1[j].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + filed1[j].getName() + \";\"); } } } 运行结果： ===============本类属性======================== private java.lang.String sex; ===============实现的接口或者父类的属性======================== public static final java.lang.String name; public static final int age; 案例：通过反射调用其它类中的方法 class hello { public static void main(String[] args) { Class demo = null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } try{ // 调用Person类中的sayChina方法 Method method=demo.getMethod(\"sayChina\"); method.invoke(demo.newInstance()); // 调用Person的sayHello方法 method=demo.getMethod(\"sayHello\", String.class,int.class); method.invoke(demo.newInstance(),\"Rollen\",20); }catch (Exception e) { e.printStackTrace(); } } } 运行结果： hello ,china Rollen 20 案例：调用其它类的set和get方法 class hello { public static void main(String[] args) { Class demo = null; Object obj=null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } try{ obj=demo.newInstance(); }catch (Exception e) { e.printStackTrace(); } setter(obj,\"Sex\",\"男\",String.class); getter(obj,\"Sex\"); } /** * @param obj * 操作的对象 * @param att * 操作的属性 * */ public static void getter(Object obj, String att) { try { Method method = obj.getClass().getMethod(\"get\" + att); System.out.println(method.invoke(obj)); } catch (Exception e) { e.printStackTrace(); } } /** * @param obj * 操作的对象 * @param att * 操作的属性 * @param value * 设置的值 * @param type * 参数的属性 * */ public static void setter(Object obj, String att, Object value, Class type) { try { Method method = obj.getClass().getMethod(\"set\" + att, type); method.invoke(obj, value); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： 男 案例：通过反射操作属性 class hello { public static void main(String[] args) throws Exception { Class demo = null; Object obj = null; demo = Class.forName(\"Reflect.Person\"); obj = demo.newInstance(); Field field = demo.getDeclaredField(\"sex\"); field.setAccessible(true); field.set(obj, \"男\"); System.out.println(field.get(obj)); } } 案例：通过反射取得并修改数组的信息 import java.lang.reflect.*; class hello{ public static void main(String[] args) { int[] temp={1,2,3,4,5}; Classdemo=temp.getClass().getComponentType(); System.out.println(\"数组类型： \"+demo.getName()); System.out.println(\"数组长度 \"+Array.getLength(temp)); System.out.println(\"数组的第一个元素: \"+Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println(\"修改之后数组第一个元素为： \"+Array.get(temp, 0)); } } 运行结果： 数组类型： int 数组长度 5 数组的第一个元素: 1 修改之后数组第一个元素为： 100 案例：通过反射修改数组大小 class hello{ public static void main(String[] args) { int[] temp={1,2,3,4,5,6,7,8,9}; int[] newTemp=(int[])arrayInc(temp,15); print(newTemp); System.out.println(\"=====================\"); String[] atr={\"a\",\"b\",\"c\"}; String[] str1=(String[])arrayInc(atr,8); print(str1); } /** * 修改数组大小 * */ public static Object arrayInc(Object obj,int len){ Classarr=obj.getClass().getComponentType(); Object newArr=Array.newInstance(arr, len); int co=Array.getLength(obj); System.arraycopy(obj, 0, newArr, 0, co); return newArr; } /** * 打印 * */ public static void print(Object obj){ Classc=obj.getClass(); if(!c.isArray()){ return; } System.out.println(\"数组长度为： \"+Array.getLength(obj)); for (int i = 0; i 运行结果： 数组长度为： 15 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 ===================== 数组长度为： 8 a b c null null null null null 案例：动态代理获得类加载器 class test{} class hello{ public static void main(String[] args) { test t=new test(); System.out.println(\"类加载器 \"+t.getClass().getClassLoader().getClass().getName()); } } 运行结果： 类加载器 sun.misc.Launcher$AppClassLoader 其实在java中有三种类类加载器。 Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类。 AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是Java中默认的加载器。 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。 package Reflect; import java.lang.reflect.*; // 定义项目接口 interface Subject { public String say(String name, int age); } // 定义真实项目 class RealSubject implements Subject { @Override public String say(String name, int age) { return name + \" \" + age; } } class MyInvocationHandler implements InvocationHandler { private Object obj = null; public Object bind(Object obj) { this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object temp = method.invoke(this.obj, args); return temp; } } class hello { public static void main(String[] args) { MyInvocationHandler demo = new MyInvocationHandler(); Subject sub = (Subject) demo.bind(new RealSubject()); String info = sub.say(\"Rollen\", 20); System.out.println(info); } } 运行结果： Rollen 20 类的生命周期 在一个类编译完成之后，下一步就需要开始使用类，如果要使用一个类，肯定离不开JVM。在程序执行中JVM通过装载，链接，初始化这3个步骤完成。 类的装载是通过类加载器完成的，加载器将.class文件的二进制文件装入JVM的方法区，并且在堆区创建描述这个类的java.lang.Class对象。用来封装数据。 但是同一个类只会被类装载器装载以前。 链接就是把二进制数据组装为可以运行的状态。 链接分为校验，准备，解析这3个阶段： 校验一般用来确认此二进制文件是否适合当前的JVM（版本） 准备就是为静态成员分配内存空间。并设置默认值 解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系） 完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收。释放空间。 当没有任何引用指向Class对象时就会被卸载，结束类的生命周期。 案例：将反射用于工厂模式 不用反射的工厂模式 interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } // 构造工厂类 // 也就是说以后如果在添加其它的实例的时候只需要修改工厂类就行了 class Factory{ public static fruit getInstance(String fruitName){ fruit f=null; if(\"Apple\".equals(fruitName)){ f=new Apple(); } if(\"Orange\".equals(fruitName)){ f=new Orange(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.getInstance(\"Orange\"); f.eat(); } } 这样，在添加一个子类的时候，就需要修改工厂类了。如果添加太多的子类的时候，改的就会很多。 利用反射机制的工厂模式 package Reflect; interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } class Factory{ public static fruit getInstance(String ClassName){ fruit f=null; try{ f=(fruit)Class.forName(ClassName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.getInstance(\"Reflect.Apple\"); if(f!=null){ f.eat(); } } } 现在就算添加任意多个子类的时候，工厂类就不需要修改。 上面的代码虽然可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。 结合属性文件的工厂模式 首先创建一个fruit.properties的资源文件，内容为： apple=Reflect.Apple orange=Reflect.Orange 主类代码： package Reflect; import java.io.*; import java.util.*; interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } // 操作属性文件类 class init{ public static Properties getPro() throws FileNotFoundException, IOException{ Properties pro=new Properties(); File f=new File(\"fruit.properties\"); if(f.exists()){ pro.load(new FileInputStream(f)); }else{ pro.setProperty(\"apple\", \"Reflect.Apple\"); pro.setProperty(\"orange\", \"Reflect.Orange\"); pro.store(new FileOutputStream(f), \"FRUIT CLASS\"); } return pro; } } class Factory{ public static fruit getInstance(String ClassName){ fruit f=null; try{ f=(fruit)Class.forName(ClassName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; } } class hello{ public static void main(String[] a) throws FileNotFoundException, IOException{ Properties pro=init.getPro(); fruit f=Factory.getInstance(pro.getProperty(\"apple\")); if(f!=null){ f.eat(); } } } 运行结果： Apple "},"core_java/grammar/p013.html":{"url":"core_java/grammar/p013.html","title":"内存区域和GC机制","keywords":"","body":"内存区域和GC机制 Java垃圾回收概况 Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。 关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。 Java GC机制主要完成3件事：确定哪些内存需要回收，确定什么时候需要执行GC，如何执行GC。经过这么长时间的发展（事实上，在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。 学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。 我们将从4个方面学习Java GC机制： 内存是如何分配的； 如何保证内存不被错误回收（即：哪些内存需要回收）； 在什么情况下执行GC以及执行GC的方式； 如何监控和优化GC机制。 Java内存区域 了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块： 程序计数器（Program Counter Register） 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。 每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。 如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。 虚拟机栈（JVM Stack） 一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。 局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。 虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。 每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。 本地方法栈（Native Method Statck） 本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。 本地方法栈也是线程私有的。 堆区（Heap） 堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。 一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。 关于堆区的内容还有很多，将在下节 Java内存分配机制 中详细介绍。 方法区（Method Area） 在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。 方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。 方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。 在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。 在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。 运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符 \"abc\" 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。 直接内存（Direct Memory） 直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。 Java对象的访问方式 一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。 以最简单的本地变量引用：Object obj = new Object()为例： Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据； new Object()作为实例对象数据存储在堆中； 堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中； 在Java虚拟机规范中，对于通过reference类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种： 通过句柄访问 （图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）： 通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。 通过直接指针访问 （图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》） 通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。 Java内存分配机制 这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。 Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation，也就是方法区）。如下图（来源于《成为JavaGC专家part I》）： 年轻代（Young Generation） 对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。 年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为（来源于《成为JavaGC专家part I》）： 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快； 最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）； 下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区； 将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区； 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。 从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。 在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread-Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。 年老代（Old Generation） 对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　　 可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。 如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。 可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——“card table”，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。 Java GC机制 GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。 年轻代 事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。 这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）。 由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1。 老年代 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。 方法区（永久代） 永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点： 类的所有实例都已经被回收 加载类的ClassLoader已经被回收 类对象的Class对象没有被引用（即没有通过反射引用该类的地方） 永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制。 -verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息 -verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用 -XX:+TraceClassUnLoading需要fastdebug版HotSpot支持 垃圾收集器 在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）： 在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。 Serial收集器 新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）。 ParNew收集器 新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器 新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效），用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。 Serial Old收集器 老年代收集器，单线程收集器，串行，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。 Parallel Old收集器 老年代收集器，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。 CMS（Concurrent Mark Sweep）收集器 老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。 CMS收集的执行过程 初始标记(CMS-initial-mark)- -> 并发标记(CMS-concurrent-mark) -->预清理(CMS-concurrent-preclean)-->可控预清理(CMS-concurrent-abortable-preclean)--> 重新标记(CMS-remark)- -> 并发清除(CMS-concurrent-sweep)- ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。 具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。 首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集； 如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc； 如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因； 当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象，CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间； 下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿，此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark； 下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间，此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean； 下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间，此阶段涉及几个参数： -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束 -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，即当eden使用达到此值时，才会开始abortable-preclean阶段 -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行 此阶段会打印一些日志如下： CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean， CMS：abort preclean due to time XXX 8，再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记； YG occupancy：964861K（2403008K），指执行时young代的情况 CMS remark：961330K（1572864K），指执行时old代的情况 此外，还打印出了弱引用处理、类卸载等过程的耗时 9，再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理 10，最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构 有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停 A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。 B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。 影响cms gc时长及触发的参数是以下2个： -XX:CMSMaxAbortablePrecleanTime=5000 -XX:CMSInitiatingOccupancyFraction=80 解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大 解决方式： A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间 C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection （cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数 在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。 CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。 还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 G1收集器 在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。 注意并发（Concurrent）和并行（Parallel）的区别： 并发是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行） 并行收集是指多个GC线程并行工作，但此时用户线程是暂停的 所以，Serial是串行的，Parallel收集器是并行的，而CMS收集器是并发的. "},"spring/p001.html":{"url":"spring/p001.html","title":"什么是 Spring 框架？Spring 框架有哪些主要模块？","keywords":"","body":"什么是 Spring 框架？Spring 框架有哪些主要模块？ Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。目的：解决企业应用开发的复杂性。功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能。范围：任何Java应用Spring是一个轻量级控制反转(IOC)和面向切面(AOP)的容器框架。 Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 "},"spring/p002.html":{"url":"spring/p002.html","title":"使用 Spring 框架能带来哪些好处？","keywords":"","body":"使用 Spring 框架能带来哪些好处？ 下面列举了一些使用 Spring 框架带来的主要好处： Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。 与 EJB 容器相比较，IOC 容器更加趋向于轻量级。这样一来 IOC 容器在有限的内存和 CPU资源的情况下进行应用程序的开发和发布就变得十分有利。 Spring 并没有闭门造车，Spring 利用了已有的技术比如 ORM 框架、logging 框架、J2EE、Quartz 和 JDK Timer，以及其他视图技术。 Spring 框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。 要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。 Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。 Spring 提供了一个便捷的事务管理接口，适用于小型的本地事务处理（比如在单 DB 的环境下）和复杂的共同事务处理（比如利用 JTA 的复杂 DB 环境）。 "},"spring/p003.html":{"url":"spring/p003.html","title":"什么是控制反转(IOC)？什么是依赖注入？","keywords":"","body":"什么是控制反转(IOC)？什么是依赖注入？ 控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 "},"spring/p004.html":{"url":"spring/p004.html","title":"请解释下 Spring 框架中的 IOC？","keywords":"","body":"请解释下 Spring 框架中的 IOC？ Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了Spring 框架 IOC 容器的基础。BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的WebApplicationContext。 "},"spring/p005.html":{"url":"spring/p005.html","title":"BeanFactory 和 ApplicationContext 有什么区别？","keywords":"","body":"BeanFactory 和 ApplicationContext 有什么区别？ BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。 BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。 提供了支持国际化的文本消息 统一的资源文件读取方式 已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。 ApplicationContext context = new ClassPathXmlApplicationContext(“application.xml”); FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 ApplicationContext context = new FileSystemXmlApplicationContext(“application.xml”); XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 "},"spring/p006.html":{"url":"spring/p006.html","title":"Spring 提供几种配置方式来设置元数据？","keywords":"","body":"Spring 提供几种配置方式来设置元数据？ 将 Spring 配置到应用开发中有以下三种方式： 基于 XML 的配置 基于注解的配置 基于 Java 的配置 "},"spring/p007.html":{"url":"spring/p007.html","title":"如何使用 XML 配置的方式配置 Spring？","keywords":"","body":"如何使用 XML 配置的方式配置 Spring？ 在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的 Spring 配置类型（比如声明的方式或基于 Java Class 的配置方式）Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 下面这个 web.xml 仅仅配置了 DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。 Archetype Created Web Application spring org.springframework.web.servlet.DispatcherServlet 1 spring / "},"spring/p008.html":{"url":"spring/p008.html","title":"如何用基于 Java 配置的方式配置 Spring？","keywords":"","body":"如何用基于 Java 配置的方式配置 Spring？ Spring 对 Java 配置的支持是由@Configuration 注解和@Bean 注解来实现的。由@Bean 注解的方法将会实例化、配置和初始化一个新对象，这个对象将由 Spring 的 IOC 容器来管理。@Bean 声明所起到的作用与 元素类似。被@Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被@Configuration 声明的类可以通过在同一个类的内部调用@bean 方法来设置嵌入 bean 的依赖关系。 最简单的@Configuration 声明类请参考下面的代码： @Configuration public class AppConfig{ @Bean public MyService myService() { return new MyServiceImpl(); } } 对于上面的@Beans 配置文件相同的 XML 配置文件如下： 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化 public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff(); } 要使用组件组建扫描，仅需用@Configuration 进行注解即可： @Configuration @ComponentScan(basePackages = \"com.gupaoedu\") public class AppConfig { } 在上面的例子中，com.gupaoedu 包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照 Sring bean 定义进行注册。如 果 你 要 在 你 的 web 应 用 开 发 中 选 用 上 述 的 配 置 的 方 式 的 话 ， 需 要 用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置 Spring 的Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。 contextClass org.springframework.web.context.support.AnnotationConfigWebApplicationContext contextConfigLocation com.gupaoedu.AppConfig org.springframework.web.context.ContextLoaderListener dispatcher org.springframework.web.servlet.DispatcherServlet contextClass org.springframework.web.context.support.AnnotationConfigWebApplicationContext contextConfigLocation com.gupaoedu.web.MVCConfig dispatcher /web/* "},"spring/p009.html":{"url":"spring/p009.html","title":"怎样用注解的方式配置 Spring？","keywords":"","body":"怎样用注解的方式配置 Spring？ Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML方式的 bean 描述，可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 在标签配置完成以后，就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。下面是几种比较重要的注解类型： @Required：该注解应用于设值方法。 @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 @Qualifier：该注解和@Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 JSR-250 Annotations ：Spring 支持 基于 JSR-250 注解 的以下 注解 ，@Resource、@PostConstruct 和 @PreDestroy。 "},"spring/p010.html":{"url":"spring/p010.html","title":"请解释 Spring Bean 的生命周期？","keywords":"","body":"请解释 Spring Bean 的生命周期？ Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean容器中移除。Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。 初始化之后调用的回调方法。 销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init()方法和 destroy()方法 @PostConstruct 和@PreDestroy 注解方式 使用 customInit()和 customDestroy()方法管理 bean 生命周期的代码样例如下： "},"spring/p011.html":{"url":"spring/p011.html","title":"Spring Bean 作用域之间的区别？","keywords":"","body":"Spring Bean 作用域之间的区别？ Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下： singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。 prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。 request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。 Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。 global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。 "},"spring/p012.html":{"url":"spring/p012.html","title":"什么是 Spring inner beans？","keywords":"","body":"什么是 Spring inner beans？ 在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。内部 bean 可以用 setter 注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例，然后在 Customer 内部使用。 public class Customer{ private Person person; //Setters and Getters } public class Person{ private String name; private String address; private int age; //Setters and Getters } 内部 bean 的声明方式如下： "},"spring/p013.html":{"url":"spring/p013.html","title":"Spring 框架中的单例 Beans 是线程安全的么？","keywords":"","body":"Spring 框架中的单例 Beans 是线程安全的么？ Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。 "},"spring/p014.html":{"url":"spring/p014.html","title":"请举例说明如何在 Spring 中注入一个 Java 集合？","keywords":"","body":"请举例说明如何在 Spring 中注入一个 Java 集合？ Spring 提供了以下四种集合类的配置元素： 该标签用来装配可重复的 list 值。 该标签用来装配没有重复的 set 值。 该标签可用来注入键和值可以为任何类型的键值对。 该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： INDIA Pakistan USA UK INDIA Pakistan USA UK admin@gupaoedu.com support@gupaoedu.com "},"spring/p015.html":{"url":"spring/p015.html","title":"如何向 Spring Bean 中注入 java.util.Properties？","keywords":"","body":"如何向 Spring Bean 中注入 java.util.Properties？ 第一种方法是使用如下面代码所示的 标签： admin@gupaoedu.com support@gupaoedu.com 也可用”util:”命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter方法注入 bean 的引用。 "},"spring/p016.html":{"url":"spring/p016.html","title":"请解释 Spring Bean 的自动装配？","keywords":"","body":"请解释 Spring Bean 的自动装配？ 在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配： 除了 bean 配置文件中提供的自动装配模式，还可以使用@Autowired 注解来自动装配指定的bean。在使用@Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。 也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 配置好以后就可以使用@Autowired 来标注了。 @Autowired public EmployeeDAOImpl ( EmployeeManager manager ) { this.manager = manager; } "},"spring/p017.html":{"url":"spring/p017.html","title":"请解释各种自动装配模式的区别？","keywords":"","body":"请解释各种自动装配模式的区别？ 在 Spring 框架中共有 5 种自动装配，让我们逐一分析。 no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean定义中用标签明确的设置依赖关系。 byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。 autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byTpe 的自动装配方式。 "},"spring/p018.html":{"url":"spring/p018.html","title":"如何开启基于注解的自动装配？","keywords":"","body":"如何开启基于注解的自动装配？ 要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 引入配置文件中的下引入 在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor "},"spring/p019.html":{"url":"spring/p019.html","title":"自动装配有哪些局限性？","keywords":"","body":"自动装配有哪些局限性？ 自动装配有如下局限性： 重写：你仍然需要使用 和设置指明依赖，这意味着总要重写自动装配。 原生数据类型：你不能自动装配简单的属性，如原生类型、字符串和类。 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 "},"spring/p020.html":{"url":"spring/p020.html","title":"在 Spring 中可以注入 null 或空字符串吗？","keywords":"","body":"在 Spring 中可以注入 null 或空字符串吗？ 完全可以。 "},"spring/p021.html":{"url":"spring/p021.html","title":"请举例解释@Required Annotation？","keywords":"","body":"请举例解释@Required Annotation？ 在产品级别的应用中，IOC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置“dependency-check”来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正 确 配 置 。 或 者 你 宁 可 验 证 某 个 bean 的 特 定 属 性 是 否 被 正 确 的 设 置 。 即 使 是 用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。需要用如下的方式使用来标明 bean 的设值方法。 public class EmployeeFactoryBean extends AbstractFactoryBean { private String designation; public String getDesignation() { return designation; } @Required public void setDesignation(String designation) { this.designation = designation; } } RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被@Required 注解的 bean 属性是否被正确的设置了。在使用 RequiredAnnotationBeanPostProcesso 来验证bean 属性之前，首先要在 IOC 容器中对其进行注册： 但 是 如 果 没 有 属 性 被 用 @Required 注 解 过 的 话 ， 后 置 处 理 器 会 抛 出 一 个BeanInitializationException 异常。 "},"spring/p022.html":{"url":"spring/p022.html","title":"请举例解释@Autowired 注解？","keywords":"","body":"请举例解释@Autowired 注解？ @Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像@Required 注解、构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。比如，可以在设值方法上使@Autowired 注解来替代配置文件中的 元素。当 Spring 容器在setter 方法上找到@Autowired 注解时，会尝试用 byType 自动装配。当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 public class TextEditor { private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker){ System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; } public void spellCheck(){ spellChecker.checkSpelling(); } } 下面是没有构造参数的配置方式： "},"spring/p023.html":{"url":"spring/p023.html","title":"请举例说明@Qualifier 注解？","keywords":"","body":"请举例说明@Qualifier 注解？ @Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 public class Customer{ @Autowired private Person person; } 下面我们要在配置文件中来配置 Person 类。 Spring 会知道要自动装配哪个 person bean 么？不会的，但是运行上面的示例时，会抛出下面的异常： Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.gupaoedu.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： public class Customer{ @Autowired @Qualifier(\"personA\") private Person person; } "},"spring/p024.html":{"url":"spring/p024.html","title":"构造方法注入和设值注入有什么区别？","keywords":"","body":"构造方法注入和设值注入有什么区别？ 请注意以下明显的区别： 在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException 异常，因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。 "},"spring/p025.html":{"url":"spring/p025.html","title":"Spring 框架中有哪些不同类型的事件？","keywords":"","body":"Spring 框架中有哪些不同类型的事件？ Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件，如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 public class AllApplicationEventListener implements ApplicationListener { @Override public void onApplicationEvent(ApplicationEvent applicationEvent) { //process event } } Spring 提供了以下 5 中标准的事件： 上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。 上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的 Start()方法开始/重新开始容器时触发该事件。 上下文停止事件（ContextStoppedEvent）：当容器调ConfigurableApplicationContext的 Stop()方法停止容器时触发该事件。 上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。 请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请（request）结束触发该事件。除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 public class CustomApplicationEvent extends ApplicationEvent{ public CustomApplicationEvent ( Object source, final String msg ){ super(source); System.out.println(\"Created a Custom event\"); } } 为了监听这个事件，还需要创建一个监听器： public class CustomEventListener implements ApplicationListener { @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) { //handle event } } 之后通过 applicationContext 接口的 publishEvent()方法来发布自定义事件。 CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext,“Test message”); applicationContext.publishEvent(customEvent); "},"spring/p026.html":{"url":"spring/p026.html","title":"FileSystemResource 和 ClassPathResource 有何区别？","keywords":"","body":"FileSystemResource 和 ClassPathResource 有何区别？ 在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把ClassPathResource 文件放在 ClassPath 下。如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src文件夹是默认。简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。 "},"spring/p027.html":{"url":"spring/p027.html","title":"Spring 框架中都用到了哪些设计模式？","keywords":"","body":"Spring 框架中都用到了哪些设计模式？ Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 代理模式—在 AOP 和 remoting 中被用的比较多。 单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。 模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 委派模式：Srping 提供了 DispatcherServlet 来对请求进行分发。 工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext接口的核心理念。 代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 "},"spring/p028.html":{"url":"spring/p028.html","title":"在 Spring 框架中如何更有效的使用 JDBC？","keywords":"","body":"在 Spring 框架中如何更有效的使用 JDBC？ 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate。 "},"spring/p029.html":{"url":"spring/p029.html","title":"Spring5 新特性","keywords":"","body":"Spring5 新特性 依赖 JDK 8+和 Java EE7+以上版本 首次采用反应式编程模型 支持使用注解进行编程 新增函数式编程 支持使用 REST 断点执行反应式编程 支持 HTTP 2.0 新增 Kotlin 和 Spring WebFlux 可使用 Lambda 表达式注册 Bean Spring WebMVC 支持最新的 API 使用 JUnit5 执行条件和并发测试 使用 Spring WebFlux 执行集成测试 核心容器优化 "}}