{"./":{"url":"./","title":"介绍","keywords":"","body":" 面试题目仓库 目前本仓库正在整理上传Java相关面试题目，题目正在逐步添加中。如发现题目问题或面试题目及相关文章推荐请留言。 在线查看：https://edu2act.github.io/interview/ 题目数量：200 知识点类型 题目数量 相关文章 16 Java基础 67 JDBC 40 Jsp&Servlet 19 Hibernate 29 Mybatis 0 Spring 29 WebService 0 设计模式 0 数据结构 0 其它 0 声明：本仓库部分图片、文章来源于网络，版权归原作者所有，如有侵权，请与我联系删除。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"article/p001.html":{"url":"article/p001.html","title":"什么是低耦合高内聚","keywords":"","body":"什么是低耦合高内聚 耦合 简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 有软硬件之间的耦合，还有软件各模块之间的耦合。 耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 耦合可以分为以下几种，它们之间的耦合度由高到低排列如下： 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。 标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合 内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p002.html":{"url":"article/p002.html","title":"Java中的作用域的区别","keywords":"","body":"Java中的作用域的区别 Java中的作用域有 public 、protected、private、default。 public：它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类，接口等，它往往用于对象或类对外的一种接口的形式。 protected：它主要的作用是用来保护子类，它的含义在于子类可以用它修饰的成员，其他的不可以，他相对于传递给子类的一种继承的东西。 private：它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是private修饰符，它不希望被外部类访问。 default：有时候也成为friendly（友元），它是针对本包访问而设计的，任何处于本包下的类，接口，异常等，都可以访问，即使是父类没有用protected修饰的成员也可以。 类内部 本包 子类 外部包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 从上面可以更直观的看到： public：可以被其他所有类访问 protected：可以被自身，子类，以及同一包下的类访问 default：可以被自身和同一包中的类访问 private：只可以被自身访问 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p003.html":{"url":"article/p003.html","title":"重载(Overload)与重写(Override)的区别","keywords":"","body":"重写(Override)与重载(Overload)的区别 方法的重写和重载是Java 多态性的不同表现。 重写Overriding 是父类与子类之间多态性的一种表现，重载Overloading 是一个类中多态性的一种表现。 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move(); // 执行 Animal 类的方法 b.move(); // 执行 Dog 类的方法 } } 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 在上面的例子中可以看到，尽管b属于Animal类型，但是它运行的是Dog类的move方法。 这是由于在编译阶段，只是检查参数的引用类型。然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。 因此在上面的例子中，之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。 思考以下例子： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } public void bark(){ System.out.println(\"狗可以吠叫\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move(); // 执行 Animal 类的方法 b.move(); // 执行 Dog 类的方法 b.bark(); } } 以上实例编译运行结果如下： TestDog.java:30: cannot find symbol symbol : method bark() location: class Animal b.bark(); ^ 该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。 方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super关键字的使用 当需要在子类中调用父类的被重写方法时，要使用super关键字。 class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal b = new Dog(); // Dog 对象 b.move(); // 执行 Dog类的方法 } } 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 重载(Overload) 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 public class Overloading { public int test(){ System.out.println(\"test1\"); return 1; } public void test(int a){ System.out.println(\"test2\"); } // 以下两个参数类型顺序不同 public String test(int a,String s){ System.out.println(\"test3\"); return \"returntest3\"; } public String test(String s,int a){ System.out.println(\"test4\"); return \"returntest4\"; } public static void main(String[] args){ Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); } } 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写和重载是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p004.html":{"url":"article/p004.html","title":"String、StringBuffer、StringBuilder的区别","keywords":"","body":"String、StringBuffer、StringBuilder的区别 重新认识String类 深入理解String、StringBuffer、StringBuilder 不同场景下三个类的性能测试 常见的关于String、StringBuffer的面试题（辟谣网上流传的一些曲解String类的说法） 重新认识String类 想要了解一个类，最好的办法就是看这个类的实现源代码，String类的实现在\\jdk1.6.0_14\\src\\java\\lang\\String.java文件中。 打开这个类文件就会发现String类是被final修饰的： public final class String implements java.io.Serializable, Comparable, CharSequence { /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ...... } 从上面可以看出几点： String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。 上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。 下面再继续看String类的一些方法实现： public String substring(int beginIndex, int endIndex) { if (beginIndex count) { throw new StringIndexOutOfBoundsException(endIndex); } if (beginIndex > endIndex) { throw new StringIndexOutOfBoundsException(endIndex - beginIndex); } return ((beginIndex == 0) && (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value); } public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf); } public String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = count; int i = -1; char[] val = value; /* avoid getfield opcode */ int off = offset; /* avoid getfield opcode */ while (++i 从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点： 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。 在了解了于String类基础的知识后，下面来看一些在平常使用中容易忽略和混淆的地方。 深入理解String、StringBuffer、StringBuilder String str=\"hello world\"和String str=new String(\"hello world\")的区别 想必大家对上面2个语句都不陌生，在平时写代码的过程中也经常遇到，那么它们到底有什么区别和联系呢？下面先看几个例子： public class Main { public static void main(String[] args) { String str1 = \"hello world\"; String str2 = new String(\"hello world\"); String str3 = \"hello world\"; String str4 = new String(\"hello world\"); System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str2==str4); } } 这段代码的输出结果为： false true false 为什么会出现这样的结果？下面解释一下原因： 在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。 因此在上述代码中， String str1 = \"hello world\"; 和 String str3 = \"hello world\"; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量\"hello world\"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。 众所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。 String、StringBuffer以及StringBuilder的区别 既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？ 那么看下面这段代码： public class Main { public static void main(String[] args) { String string = \"\"; for(int i=0;i 这句 string += \"hello\"; 的过程相当于将原有的string变量指向的对象内容取出与\"hello\"作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了： 从这段反编译出的字节码文件可以很清楚地看出：从第8行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。从上面还可以看出：string+=\"hello\" 的操作事实上会自动被JVM优化成： StringBuilder str = new StringBuilder(string); str.append(\"hello\"); str.toString(); 再看下面这段代码： public class Main { public static void main(String[] args) { StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i 反编译字节码文件得到： 从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。 那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的，也就是说StringBuffer是线程安全的。 下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现： StringBuilder的insert方法 public StringBuilder insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } StringBuffer的insert方法 public synchronized StringBuffer insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } 不同场景下三个类的性能测试 这一小节我们来做个小测试，来测试一下三个类的性能区别： public class Main { private static int time = 50000; public static void main(String[] args) { testString(); testStringBuffer(); testStringBuilder(); test1String(); test2String(); } public static void testString () { String s=\"\"; long begin = System.currentTimeMillis(); for(int i=0; i 测试结果（Win7，Eclipse，JDK6）： 操作java.lang.String类型使用的时间为：8090毫秒 操作java.lang.StringBuffer类型使用的时间为：3毫秒 操作java.lang.StringBuilder类型使用的时间为：2毫秒 字符串直接相加操作：1毫秒 字符串间接相加操作：9毫秒 上面提到 string+=\"hello\" 的操作事实上会自动被JVM优化，看下面这段代码： public class Main { private static int time = 50000; public static void main(String[] args) { testString(); testOptimalString(); } public static void testString () { String s=\"\"; long begin = System.currentTimeMillis(); for(int i=0; i 执行结果： 操作java.lang.String类型使用的时间为：8654毫秒 模拟JVM优化操作的时间为：8651毫秒 得到验证。 下面对上面的执行结果进行一般性的解释： 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如 \"I\"+\"love\"+\"java\"; 的字符串相加，在编译期间便被优化成了\"Ilovejava\"。这个可以用javap -c命令反编译生成的class文件进行验证。对于间接相加（即包含字符串引用），形如 s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 String、StringBuilder、StringBuffer三者的执行效率： StringBuilder > StringBuffer > String 当然这个是相对的，不一定在所有情况下都是这样。 比如 String str = \"hello\"+ \"world\" 的效率就比 StringBuilder st = new StringBuilder().append(\"hello\").append(\"world\") 要高。 因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\" 这种形式； 当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 常见的关于String、StringBuffer的面试题 下面是一些常见的关于String、StringBuffer的一些面试笔试题，若有不正之处，请谅解和批评指正。 下面这段代码的输出结果是什么？ String a = \"hello2\"; String b = \"hello\" + 2; System.out.println((a == b)); 输出结果为：true。原因很简单，\"hello\"+2在编译期间就已经被优化成\"hello2\"，因此在运行期间，变量a和变量b指向的是同一个对象。 下面这段代码的输出结果是什么？ String a = \"hello2\"; String b = \"hello\"; String c = b + 2; System.out.println((a == c)); 输出结果为:false。由于有符号引用的存在，所以 String c = b + 2; 不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。 下面这段代码的输出结果是什么？ String a = \"hello2\"; final String b = \"hello\"; String c = b + 2; System.out.println((a == c)); 输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么 String c = b + 2; 在编译期间就会被优化成：String c = \"hello\" + 2;。 下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { String a = \"hello2\"; final String b = getHello(); String c = b + 2; System.out.println((a == c)); } public static String getHello() { return \"hello\"; } } 输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。 下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { String a = \"hello\"; String b = new String(\"hello\"); String c = new String(\"hello\"); String d = b.intern(); System.out.println(a==b); System.out.println(b==c); System.out.println(b==d); System.out.println(a==d); } } false false false true 这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在Java se6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。 String str = new String(\"abc\")创建了多少个对象？ 这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。 首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容： 很显然，new只调用了一次，也就是说只创建了一个对象。 而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了\"abc\"对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个\"abc\"对象，而在代码执行过程中确实只创建了一个String对象。 因此，这个问题如果换成 String str = new String(\"abc\") 涉及到几个String对象？合理的解释是2个。 个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚是这段代码执行过程中创建了多少个对象还是涉及到多少个对象再根据具体的来进行回答。 下面这段代码[1]和[2]的区别是什么？ public class Main { public static void main(String[] args) { String str1 = \"I\"; // str1 += \"love\"+\"java\"; // [1] str1 = str1+\"love\"+\"java\"; // [2] } } [1]的效率比[2]的效率要高，[1]中的 \"love\"+\"java\" 在编译期间会被优化成 \"lovejava\"，而[2]中的不会被优化。下面是两种方式的字节码： [1]的字节码 [2]的字节码 可以看出，在[1]中只进行了一次append操作，而在[2]中进行了两次append操作。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p005.html":{"url":"article/p005.html","title":"类加载与初始化","keywords":"","body":"类加载与初始化 类加载器 在了解Java的机制之前，需要先了解类在JVM（Java虚拟机）中是如何加载的，这对后面理解java其它机制将有重要作用。 每个类编译后产生一个Class对象，存储在.class文件中，JVM使用类加载器（Class Loader）来加载类的字节码文件（.class），类加载器实质上是一条类加载器链，一般的，我们只会用到一个原生的类加载器，它只加载Java API等可信类，通常只是在本地磁盘中加载，这些类一般就够我们使用了。如果我们需要从远程网络或数据库中下载.class字节码文件，那就需要我们来挂载额外的类加载器。 一般来说，类加载器是按照树形的层次结构组织的，每个加载器都有一个父类加载器。另外，每个类加载器都支持代理模式，即可以自己完成Java类的加载工作，也可以代理给其它类加载器。 类加载器的加载顺序有两种，一种是父类优先策略，一种是是自己优先策略，父类优先策略是比较一般的情况（如JDK采用的就是这种方式），在这种策略下，类在加载某个Java类之前，会尝试代理给其父类加载器，只有当父类加载器找不到时，才尝试自己去加载。自己优先的策略与父类优先相反，它会首先尝试子经济加载，找不到的时候才要父类加载器去加载，这种在web容器（如tomcat）中比较常见。 动态加载 不管使用什么样的类加载器，类，都是在第一次被用到时，动态加载到JVM的。这句话有两层含义： Java程序在运行时并不一定被完整加载，只有当发现该类还没有加载时，才去本地或远程查找类的.class文件并验证和加载； 当程序创建了第一个对类的静态成员的引用（如类的静态变量、静态方法、构造方法——构造方法也是静态的）时，才会加载该类。Java的这个特性叫做：动态加载。 需要区分加载和初始化的区别，加载了一个类的.class文件，不以为着该Class对象被初始化，事实上，一个类的初始化包括3个步骤： 加载（Loading），由类加载器执行，查找字节码，并创建一个Class对象（只是创建）； 链接（Linking），验证字节码，为静态域分配存储空间（只是分配，并不初始化该存储空间），解析该类创建所需要的对其它类的应用； 初始化（Initialization），首先执行静态初始化块static{}，初始化静态变量，执行静态方法（如构造方法）。 链接 Java在加载了类之后，需要进行链接的步骤，链接简单地说，就是将已经加载的java二进制代码组合到JVM运行状态中去。它包括3个步骤： 验证（Verification），验证是保证二进制字节码在结构上的正确性，具体来说，工作包括检测类型正确性，接入属性正确性（public、private），检查final class 没有被继承，检查静态变量的正确性等。 准备（Preparation），准备阶段主要是创建静态域，分配空间，给这些域设默认值，需要注意的是两点：一个是在准备阶段不会执行任何代码，仅仅是设置默认值，二个是这些默认值是这样分配的，原生类型全部设为0，如：float:0f,int 0, long 0L, boolean:0（布尔类型也是0），其它引用类型为null。 解析（Resolution），解析的过程就是对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址），并保证这些类被正确的找到。解析的过程可能导致其它的类被加载。需要注意的是，根据不同的解析策略，这一步不一定是必须的，有些解析策略在解析时递归的把所有引用解析，这是early resolution，要求所有引用都必须存在；还有一种策略是late resolution，这也是Oracle 的JDK所采取的策略，即在类只是被引用了，还没有被真正用到时，并不进行解析，只有当真正用到了，才去加载和解析这个类。 初始化 注意：在《Java编程思想》中，说static{}子句是在类第一次加载时执行且执行一次（可能是笔误或翻译错误，因为此书的例子显示static是在第 一次初始化时执行的），《Java深度历险》中说 static{}是在第一次实例化时执行且执行一次，这两种应该都是错误的，static{}是在第一次初始化时执行，且只执行一次；用下面的代码可以判 定出来： public class Toy { private String name; public static final int price=10; static { System.out.println(\"Initializing\"); } Toy() { System.out.println(\"Building\"); } Toy(String name) { this.setName(name); } public static String playToy(String player) { String msg = buildMsg(player); System.out.println(msg); return msg; } private String buildMsg(String player) { String msg = player + \" plays \" + name; return msg; } } // 对上面的类，执行下面的代码： Class c = Class.forName(\"myblog.rtti.Toy\"); // c.newInstance(); 可以看到，不实例化，只执行forName初始化时，仍然会执行static{}子句，但不执行构造方法，因此输出的只有Initializing，没有Building。 根据java虚拟机规范，所有java虚拟机实现必须在每个类或接口被java程序首次主动使用时才初始化。 主动使用有以下6种： 创建类的实例 访问某个类或者接口的静态变量，或者对该静态变量赋值（如果访问静态编译时常量(即编译时可以确定值的常量)不会导致类的初始化） 调用类的静态方法 反射（Class.forName(xxx.xxx.xxx)） 初始化一个类的子类（相当于对父类的主动使用），不过直接通过子类引用父类元素，不会引起子类的初始化（参见示例6） Java虚拟机被标明为启动类的类（包含main方法的） 类与接口的初始化不同，如果一个类被初始化，则其父类或父接口也会被初始化，但如果一个接口初始化，则不会引起其父接口的初始化。 示例 通过上面的讲解，将可以理解下面的程序 （下面的程序部分来自于《Java编程思想》）： class Toy { static { // 静态子句，只在类第一次被加载并初始化时执行一次，而且只执行一次 System.out.println(\"Initializing\"); } Toy() { // 构造方法，在每次声明新对象时加载 System.out.println(\"Building\"); } } 对上面的程序段，第一次调用Class.forName(\"Toy\")，将执行static子句；如果在之后执行new Toy()都只执行构造方法。 需要注意newInstance()方法 Class cc = Class.forName(\"Toy\");// 获得类（注意，需要使用含包名的全限定名） Toy toy=(Toy)cc.newInstance(); // 相当于new一个对象，但Gum类必须有默认构造方法（无参） 类字面常量 用类字面常量 .class和Class.forName都可以创建对类的应用，但是不同点在于，用Gum.class创建Class对象的应用时，不会自动初始化该Class对象（static子句不会执行） public class TestToy { public static void main(String[] args) { // try { // Class c = Class.forName(\"myblog.classloader.Toy\"); // } catch (ClassNotFoundException e) { // e.printStackTrace(); // } Class c = Toy.class; // 不会输出任何值 } } 使用Toy.class是在编译期执行的，因此在编译时必须已经有了Toy的.class文件，不然会编译失败，这与 Class.forName(\"myblog.classloader.Toy\")不同，后者是运行时动态加载。 但是，如果该main方法是直接写在Toy类中，那么调用Toy.class，会引起初始化，并输出Initializing，原因并不是Toy.class引起的，而是该类中含有启动方法main，该方法会导致Toy的初始化。 编译时常量 回到完整的类Toy，如果直接输出：System.out.println(Toy.price)，会发现static子句和构造方法都没有被执行，这是因为Toy中，常量price被static final限定，这样的常量叫做编译时常量，对于这种常量，不需要初始化就可以读取。 编译时常量必须满足3个条件：static的，final的，常量。 下面几种都不是编译时常量，对它们的应用，都会引起类的初始化： static int a; final int b; static final int c= ClassInitialization.rand.nextInt(100); static final int d; static { d=5; } static块的本质 注意下面的代码： class StaticBlock { static final int c = 3; static final int d; static int e = 5; static { d = 5; e = 10; System.out.println(\"Initializing\"); } StaticBlock() { System.out.println(\"Building\"); } } public class StaticBlockTest { public static void main(String[] args) { System.out.println(StaticBlock.c); System.out.println(StaticBlock.d); System.out.println(StaticBlock.e); } } 这段代码的输出是什么呢？Initialing在c、d、e之前输出，还是在之后？e输出的是5还是10？ 执行一下，结果为： 3 Initializing 5 10 答案是3最先输出，Intializing随后输出，e输出的是10，为什么呢？ 原因是这样的：输出c时，由于c是编译时常量，不会引起类初始化，因此直接输出，输出d时，d不是编译时常量，所以会引起初始化操作，即static块的执行，于是d被赋值为5，e被赋值为10，然后输出Initializing，之后输出d为5，e为10。 但e为什么是10呢？原来，JDK会自动为e的初始化创建一个static块，所以上面的代码等价于： class StaticBlock { static final int d; static int e; static { e=5; } static { d = 5; e = 10; System.out.println(\"Initializing\"); } StaticBlock() { System.out.println(\"Building\"); } } 可见，按顺序执行，e先被初始化为5，再被初始化为10，于是输出了10。 类似的，容易想到下面的代码： class StaticBlock { static { d = 5; e = 10; System.out.println(\"Initializing\"); } static final int d; static int e = 5; StaticBlock() { System.out.println(\"Building\"); } } 在这段代码中，对e的声明被放到static块后面，于是，e会先被初始化为10，再被初始化为5，所以这段代码中e会输出为5。 当访问一个Java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化 class B { static int value = 100; static { System.out.println(\"Class B is initialized\");// 输出 } } class A extends B { static { System.out.println(\"Class A is initialized\"); // 不输出 } } public class SuperClassTest { public static void main(String[] args) { System.out.println(A.value);// 输出100 } } 在该例子中，虽然通过A来引用了value，但value是在父类B中声明的，所以只会初始化B，而不会引起A的初始化 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p006.html":{"url":"article/p006.html","title":"RTTI和反射机制","keywords":"","body":"RTTI和反射机制 类加载器 并不是所有的Class都能在编译时明确，因此在某些情况下需要在运行时再发现和确定类型信息（比如：基于构建编程，），这就是RTTI（Runtime Type Information，运行时类型信息）。 在Java中，有两种RTTI的方式，一种是传统的，即假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。 在本文中，将共同使用下面的玩具类Toy，该类中定义了公有、私有方法，变量，构造方法，父类、父接口等： public interface IToy { public String playToy(String player) throws Exception; } public class AbstractToy implements IToy { @Override public String playToy(String player) throws Exception { System.out.println(player + \" plays abstract toy\"); return \"\"; } } public class Toy extends AbstractToy { private String name; public String color; protected int size; public static final int price = 10; static { System.out.println(\"Loading\"); } // 构造方法一定要声明为public类型，不然用getConstructors无法得到 public Toy() { System.out.println(\"Initialing\"); setName(\"myToy\"); color = \"red\"; size = 5; } public Toy(String name, String color, int size) { this.setName(name); this.color = color; this.size = size; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String playToy(String player) throws Exception { String msg = buildMsg(player); System.out.println(msg); return msg; } private String buildMsg(String player) { String msg = player + \" plays \" + name; return msg; } } 传统的RTTI 严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为RTTI指的是传统的RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能（超类会自动实例化为子类，或使用instance of）。 传统的RTTI有3种实现方式： 向上转型或向下转型（upcasting and downcasting），在java中，向下转型（父类转成子类）需要强制类型转换 Class对象（用了Class对象，不代表就是反射，如果只是用Class对象cast成指定的类，那就还是传统的RTTI） instanceof或isInstance() 传统的RTTI与反射最主要的区别，在于RTTI在编译期需要.class文件，而反射不需要。传统的RTTI使用转型或Instance形式实现，但都需要指定要转型的类型，比如： public void rtti(Object obj){ Toy toy = Toy(obj); // Toy toy = Class.forName(\"myblog.rtti.Toy\") // obj instanceof Toy } 注意其中的obj虽然是被转型了，但在编译期，就需要知道要转成的类型Toy，也就是需要Toy的.class文件。 相对的，反射完全在运行时在通过Class类来确定类型，不需要提前加载Toy的.class文件。 反射 那到底什么是反射（Reflection）呢？反射有时候也被称为内省（Introspection），事实上，反射，就是一种内省的方式，Java不允许在运行时改变程序结构或类型变量的结构，但它允许在运行时去探知、加载、调用在编译期完全未知的class，可以在运行时加载该class，生成实例对象（instance object），调用method，或对field赋值。这种类似于“看透”了class的特性被称为反射（Reflection），我们可以将反射直接理解为：可以看到自己在水中的倒影，这种操作与直接操作源代码效果相同，但灵活性高得多。 关于Java的反射API，没必要去记忆，可以在任何JDK API中查询即可： Class类：http://www.ostools.net/uploads/apidocs/jdk-zh/java/lang/Class.html reflect包：http://www.ostools.net/uploads/apidocs/jdk-zh/java/lang/reflect/package-summary.html 反射的实现方式 import java.lang.reflect.Array; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; public class ToyReflection { public static void printInfo(String info, Object obj) { if (obj.getClass().isArray()) { System.out.println(info + \": \"); int length = Array.getLength(obj); System.out.println(\"Array Size: \" + length); for (int i = 0; i c = Class.forName(\"myblog.rtti.Toy\"); printInfo(\"获得类对象\", c); // 获得超类 Class superClass = c.getSuperclass(); printInfo(\"获得超类\", superClass); // 获得所有父接口 Class[] interfaces = c.getInterfaces(); printInfo(\"获得所有父接口\", interfaces); // 实例化 Toy toy = (Toy) c.newInstance(); printInfo(\"实例化\", toy); // 获得访问属性为public的构造方法 Constructor[] constructors = c.getConstructors(); printInfo(\"获得构造方法\", constructors); // 获得指定参数的构造方法 Constructor constructor = c.getDeclaredConstructor(String.class, String.class, int.class); printInfo(\"获得指定构造方法\", constructor); // 获得方法，getMethod只能获得public方法，包括父类和接口继承的方法 Method method = c.getMethod(\"playToy\", String.class); printInfo(\"获得公有方法\", method); // 调用方法 method.invoke(toy, \"张三\"); // 获得修饰符，包括private/public/protect,static String modifier = Modifier.toString(method.getModifiers()); printInfo(\"获得修饰符\", modifier); // 获得参数类型 Class[] paramTypes = method.getParameterTypes(); printInfo(\"获得参数类型\", paramTypes); // 获得返回值类型 Class returnType = method.getReturnType(); printInfo(\"获得返回值类型\", returnType); // 获得异常类型 Class[] excepTypes = method.getExceptionTypes(); printInfo(\"获得异常类型\", excepTypes); // 调用私有方法，getDeclaredMethod获得类自身的方法，包括public,protect,private方法 Method method2 = c.getDeclaredMethod(\"buildMsg\", String.class); method2.setAccessible(true); String result = (String) method2.invoke(toy, \"李四\"); printInfo(\"获得私有方法\", result); // 获得全部属性 Field[] fields = c.getFields(); printInfo(\"获得全部属性\", fields); // 获得类自身定义的指定属性 Field field = c.getDeclaredField(\"name\"); printInfo(\"获得自身属性\", field); // 获得类及其父类，父接口定义的public属性 Field field2 = c.getField(\"color\"); printInfo(\"获得公有属性\", field2); // 获得权限修饰符，包括private/public/protect,static,final String fieldModifier = Modifier.toString(field.getModifiers()); printInfo(\"获得权限修饰符\", fieldModifier); // 操作数组 int[] exampleArray = { 1, 2, 3, 4, 5 }; // 获得数组类型 Class componentType = exampleArray.getClass().getComponentType(); printInfo(\"数组类型\", componentType.getName()); // 获得长度 printInfo(\"数组长度\", Array.getLength(exampleArray)); // 获得指定元素 printInfo(\"获得数组元素\", Array.get(exampleArray, 2)); // 修改指定元素 Array.set(exampleArray, 2, 6); printInfo(\"修改数组元素\", exampleArray); // 获得当前的类加载器 printInfo(\"获得当前类加载器\", toy.getClass().getClassLoader().getClass().getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } } 通过上面的代码，可以清晰的理解如何“在水中看到自己”，不过需要注意的有几点： 在java的反射机制中，getDeclaredMethod得到的是全部方法，getMethod得到的是公有方法； 反射机制的setAccessible可能会破坏封装性，可以任意访问私有方法和私有变量； setAccessible并不是将private改为public，事实上，public方法的accessible属性也是false的，setAccessible只是取消了安全访问控制检查，所以通过设置setAccessible，可以跳过访问控制检查，执行的效率也比较高。参考：提高Java反射速度 反射的性能 反射机制给予Java开发很大的灵活性，但反射机制本身也有缺点，代表性的缺陷就是反射的性能，一般来说，通过反射调用方法的效率比直接调用的效率要至少慢一倍以上。参考：反射性能测试 反射与设计模式 反射的一个很重要的作用，就是在设计模式中的应用，包括在工厂模式和代理模式中的应用。参考：反射使用实例详解 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p007.html":{"url":"article/p007.html","title":"提高Java反射速度","keywords":"","body":"提高Java反射速度 提高java反射速度的方法method.setAccessible(true) Java代码中，常常将一个类的成员变量置为private，在类的外面获取此类的私有成员变量的value时，需要注意: public class AccessibleTest { private int id; private String name; public AccessibleTest() {} public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Main { public static void main(String[] args) throws Exception { Class clazz = Class.forName(\"com.test.accessible.AccessibleTest\"); AccessibleTest at = new AccessibleTest(); at.setId(1); at.setName(\"AT\"); for (Field f : clazz.getDeclaredFields()) { // AccessibleTest类中的成员变量为private,故必须进行此操作 f.setAccessible(true); // 获取当前对象中当前Field的value System.out.println(f.get(at)); } } } 如果没有在获取Field之前调用setAccessible(true)方法，异常： java.lang.IllegalAccessException: Class com.test.accessible.Main can not access a member of class com.test.accessible.AccessibleTest with modifiers \"private\" 当然在AccessibleTest类的内部(AccessibleTest的内部类除外)，进行如上操作则不需要调用setAccesible()方法。 明显 Accessible并不是标识方法能否访问的。public的方法 Accessible仍为false，使用了method.setAccessible(true)后 性能有了20倍的提升，Accessable属性是继承自AccessibleObject 类。 功能是启用或禁用安全检查 JDK API中的解释 AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获得字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。 在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象。 setAccessible public void setAccessible(boolean flag) throws SecurityException 将此对象的 accessible 标志设置为指示的布尔值。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。 实际上setAccessible是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p008.html":{"url":"article/p008.html","title":"反射性能测试","keywords":"","body":"反射性能测试 通过对比静态调用与类反射调用方法的效率，来了解现代框架中大量应用的反射调用对性能的影响程度。以便在系统架构中对性能与开发便利性之间进行权衡与取舍。 代码： public class PerformanceTest { public static void main(String[] args) throws Exception { int testTime = 10000000; PerformanceTest test = new PerformanceTest(); String msg = \"this is test message\"; long bTime = System.currentTimeMillis(); for(int i=0; i 测试结果： 930 5369 898 5052 885 5346 889 4992 对比代码的测试结果，没有缓存被调用方法的情况下，性能损失更为严重。 而考虑在框架级实现中，缓存是通过map等机制进行的，那么在获取缓存时的时间成本也要计算在内，则整体性能对比将在上述两个测试之间。 考虑目前的计算机系统的速度，应用开发已经不在那么介意性能，而更为注重系统的可维护性和扩展性以及快速开发效率上。上述的测试结果是在一千万次的测试基础上产生的。而在通常的一次业务请求中，反射使用的次数应该是非常少的，只在框架级基础上被使用，在一个高负载的系统中，业务处理的性能将是关键点，而不在于使用的这些反射所带来的性能影响上。而使用反射所带来的开发便利与可维护性可扩展性的提升所带来的价值，是远远高于其所损耗的性能的。 又回想起原来在某个所谓高性能项目中通过减少反射来提高性能的做法，现在想来，比较愚蠢。这说明前期的测试工作没有到位，而带来这样的结论偏差，从而导致了开发与维护的不便，而且极大地影响了开发速度。 其实那个系统的大部分性能瓶颈都是在数据库上，大部分的业务处理都是在数据库中进行的，在项目后面的性能测试中发现，WEB服务器的负载非常低，远远低于数据库，大部分的操作都是在等待数据库的返回。 前期某些推论既没有经过验证，也没有相关的使用经验来支持此推论，是导致这种错误的根源。在将来的架构设计工作与框架选型要加强这方面的评估工作，来达到性能与开发效率间的最佳平衡。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p009.html":{"url":"article/p009.html","title":"反射使用实例详解","keywords":"","body":"反射使用实例详解 本篇文章依旧采用小例子来说明，案例驱动是最好的，要不然只看理论的话，看了也不懂，不过建议大家在看完文章之后，在回过头去看看理论，会有更好的理解。 案例：通过一个对象获得完整的包名和类名 package Reflect; /** * 通过一个对象获得完整的包名和类名 * */ class Demo{ //other codes... } class hello{ public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.getClass().getName()); } } 运行结果： Reflect.Demo 所有类的对象其实都是Class的实例。 案例：实例化Class类对象 package Reflect; class Demo{ //other codes... } class hello{ public static void main(String[] args) { Class demo1=null; Class demo2=null; Class demo3=null; try{ // 一般尽量采用这种形式 demo1=Class.forName(\"Reflect.Demo\"); }catch(Exception e){ e.printStackTrace(); } demo2=new Demo().getClass(); demo3=Demo.class; System.out.println(\"类名称 \"+demo1.getName()); System.out.println(\"类名称 \"+demo2.getName()); System.out.println(\"类名称 \"+demo3.getName()); } } 运行结果： 类名称 Reflect.Demo 类名称 Reflect.Demo 类名称 Reflect.Demo 案例：通过Class实例化其他类的对象 通过无参构造实例化对象 package Reflect; class Person{ public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString(){ return \"[\"+this.name+\" \"+this.age+\"]\"; } private String name; private int age; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Person per=null; try { per=(Person)demo.newInstance(); } catch (InstantiationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } per.setName(\"Rollen\"); per.setAge(20); System.out.println(per); } } 运行结果： [Rollen 20] 但是注意一下，当我们把Person中的默认的无参构造函数取消的时候，比如自己定义只定义一个有参数的构造函数之后，会出现错误。 比如我定义了一个构造函数： public Person(String name, int age) { this.age=age; this.name=name; } 然后继续运行上面的程序，会出现： java.lang.InstantiationException: Reflect.Person at java.lang.Class.newInstance0(Class.java:340) at java.lang.Class.newInstance(Class.java:308) at Reflect.hello.main(hello.java:39) Exception in thread \"main\" java.lang.NullPointerException at Reflect.hello.main(hello.java:47) 所以在编写使用Class实例化其他类的对象的时候，一定要自己定义无参的构造函数。 案例：通过Class调用其它类中的构造函数 也可以通过这种方式通过Class创建其它类的对象。 package Reflect; import java.lang.reflect.Constructor; class Person{ public Person() {} public Person(String name){ this.name=name; } public Person(int age){ this.age=age; } public Person(String name, int age) { this.age=age; this.name=name; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString(){ return \"[\"+this.name+\" \"+this.age+\"]\"; } private String name; private int age; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Person per1=null; Person per2=null; Person per3=null; Person per4=null; // 取得全部的构造函数 Constructor cons[]=demo.getConstructors(); try{ per1=(Person)cons[0].newInstance(); per2=(Person)cons[1].newInstance(\"Rollen\"); per3=(Person)cons[2].newInstance(20); per4=(Person)cons[3].newInstance(\"Rollen\",20); }catch(Exception e){ e.printStackTrace(); } System.out.println(per1); System.out.println(per2); System.out.println(per3); System.out.println(per4); } } 运行结果： [null 0] [Rollen 0] [null 20] [Rollen 20] 案例：返回一个类实现的接口 package Reflect; interface China{ public static final String name=\"Rollen\"; public static int age=20; public void sayChina(); public void sayHello(String name, int age); } class Person implements China{ public Person() {} public Person(String sex){ this.sex=sex; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } @Override public void sayChina(){ System.out.println(\"hello ,china\"); } @Override public void sayHello(String name, int age){ System.out.println(name+\" \"+age); } private String sex; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } // 保存所有的接口 Class intes[]=demo.getInterfaces(); for (int i = 0; i 运行结果： 实现的接口 Reflect.China PS：以下几个例子，都会用到这个例子的Person类，所以为节省篇幅，此处不再粘贴Person的代码部分，只粘贴主类hello的代码。 案例：取得其它类中的父类 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } // 取得父类 Class temp=demo.getSuperclass(); System.out.println(\"继承的父类为： \"+temp.getName()); } } 运行结果： 继承的父类为： java.lang.Object 案例：获得其他类中的全部构造函数 这个例子需要在程序开头添加import java.lang.reflect.*; 然后将主类编写为： class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Constructorcons[]=demo.getConstructors(); for (int i = 0; i 运行结果： 构造方法： public Reflect.Person() 构造方法： public Reflect.Person(java.lang.String) 但是细心的话会发现，上面的构造函数没有public 或者private这一类的修饰符，下面这个例子就来获取修饰符。 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Constructorcons[]=demo.getConstructors(); for (int i = 0; i p[]=cons[i].getParameterTypes(); System.out.print(\"构造方法： \"); int mo=cons[i].getModifiers(); System.out.print(Modifier.toString(mo)+\" \"); System.out.print(cons[i].getName()); System.out.print(\"(\"); for(int j=0;j 运行结果： 构造方法： public Reflect.Person(){} 构造方法： public Reflect.Person(java.lang.String arg1){} 有时候一个方法可能还有异常。 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Method method[]=demo.getMethods(); for(int i=0;i returnType=method[i].getReturnType(); Class para[]=method[i].getParameterTypes(); int temp=method[i].getModifiers(); System.out.print(Modifier.toString(temp)+\" \"); System.out.print(returnType.getName()+\" \"); System.out.print(method[i].getName()+\" \"); System.out.print(\"(\"); for(int j=0;j exce[]=method[i].getExceptionTypes(); if(exce.length>0){ System.out.print(\") throws \"); for(int k=0;k 运行结果： public java.lang.String getSex () public void setSex (java.lang.String arg0) public void sayChina () public void sayHello (java.lang.String arg0,int arg1) public final native void wait (long arg0) throws java.lang.InterruptedException public final void wait () throws java.lang.InterruptedException public final void wait (long arg0,int arg1) throws java.lang.InterruptedException public boolean equals (java.lang.Object arg0) public java.lang.String toString () public native int hashCode () public final native java.lang.Class getClass () public final native void notify () public final native void notifyAll () 案例：取得其它类的全部属性 通过class取得一个类的全部框架 class hello { public static void main(String[] args) { Class demo = null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"===============本类属性========================\"); // 取得本类的全部属性 Field[] field = demo.getDeclaredFields(); for (int i = 0; i type = field[i].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + field[i].getName() + \";\"); } System.out.println(\"===============实现的接口或者父类的属性========================\"); // 取得实现的接口或者父类的属性 Field[] filed1 = demo.getFields(); for (int j = 0; j type = filed1[j].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + filed1[j].getName() + \";\"); } } } 运行结果： ===============本类属性======================== private java.lang.String sex; ===============实现的接口或者父类的属性======================== public static final java.lang.String name; public static final int age; 案例：通过反射调用其它类中的方法 class hello { public static void main(String[] args) { Class demo = null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } try{ // 调用Person类中的sayChina方法 Method method=demo.getMethod(\"sayChina\"); method.invoke(demo.newInstance()); // 调用Person的sayHello方法 method=demo.getMethod(\"sayHello\", String.class,int.class); method.invoke(demo.newInstance(),\"Rollen\",20); }catch (Exception e) { e.printStackTrace(); } } } 运行结果： hello ,china Rollen 20 案例：调用其它类的set和get方法 class hello { public static void main(String[] args) { Class demo = null; Object obj=null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } try{ obj=demo.newInstance(); }catch (Exception e) { e.printStackTrace(); } setter(obj,\"Sex\",\"男\",String.class); getter(obj,\"Sex\"); } /** * @param obj * 操作的对象 * @param att * 操作的属性 * */ public static void getter(Object obj, String att) { try { Method method = obj.getClass().getMethod(\"get\" + att); System.out.println(method.invoke(obj)); } catch (Exception e) { e.printStackTrace(); } } /** * @param obj * 操作的对象 * @param att * 操作的属性 * @param value * 设置的值 * @param type * 参数的属性 * */ public static void setter(Object obj, String att, Object value, Class type) { try { Method method = obj.getClass().getMethod(\"set\" + att, type); method.invoke(obj, value); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： 男 案例：通过反射操作属性 class hello { public static void main(String[] args) throws Exception { Class demo = null; Object obj = null; demo = Class.forName(\"Reflect.Person\"); obj = demo.newInstance(); Field field = demo.getDeclaredField(\"sex\"); field.setAccessible(true); field.set(obj, \"男\"); System.out.println(field.get(obj)); } } 案例：通过反射取得并修改数组的信息 import java.lang.reflect.*; class hello{ public static void main(String[] args) { int[] temp={1,2,3,4,5}; Classdemo=temp.getClass().getComponentType(); System.out.println(\"数组类型： \"+demo.getName()); System.out.println(\"数组长度 \"+Array.getLength(temp)); System.out.println(\"数组的第一个元素: \"+Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println(\"修改之后数组第一个元素为： \"+Array.get(temp, 0)); } } 运行结果： 数组类型： int 数组长度 5 数组的第一个元素: 1 修改之后数组第一个元素为： 100 案例：通过反射修改数组大小 class hello{ public static void main(String[] args) { int[] temp={1,2,3,4,5,6,7,8,9}; int[] newTemp=(int[])arrayInc(temp,15); print(newTemp); System.out.println(\"=====================\"); String[] atr={\"a\",\"b\",\"c\"}; String[] str1=(String[])arrayInc(atr,8); print(str1); } /** * 修改数组大小 * */ public static Object arrayInc(Object obj,int len){ Classarr=obj.getClass().getComponentType(); Object newArr=Array.newInstance(arr, len); int co=Array.getLength(obj); System.arraycopy(obj, 0, newArr, 0, co); return newArr; } /** * 打印 * */ public static void print(Object obj){ Classc=obj.getClass(); if(!c.isArray()){ return; } System.out.println(\"数组长度为： \"+Array.getLength(obj)); for (int i = 0; i 运行结果： 数组长度为： 15 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 ===================== 数组长度为： 8 a b c null null null null null 案例：动态代理获得类加载器 class test{} class hello{ public static void main(String[] args) { test t=new test(); System.out.println(\"类加载器 \"+t.getClass().getClassLoader().getClass().getName()); } } 运行结果： 类加载器 sun.misc.Launcher$AppClassLoader 其实在java中有三种类类加载器。 Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类。 AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是Java中默认的加载器。 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。 package Reflect; import java.lang.reflect.*; // 定义项目接口 interface Subject { public String say(String name, int age); } // 定义真实项目 class RealSubject implements Subject { @Override public String say(String name, int age) { return name + \" \" + age; } } class MyInvocationHandler implements InvocationHandler { private Object obj = null; public Object bind(Object obj) { this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object temp = method.invoke(this.obj, args); return temp; } } class hello { public static void main(String[] args) { MyInvocationHandler demo = new MyInvocationHandler(); Subject sub = (Subject) demo.bind(new RealSubject()); String info = sub.say(\"Rollen\", 20); System.out.println(info); } } 运行结果： Rollen 20 类的生命周期 在一个类编译完成之后，下一步就需要开始使用类，如果要使用一个类，肯定离不开JVM。在程序执行中JVM通过装载，链接，初始化这3个步骤完成。 类的装载是通过类加载器完成的，加载器将.class文件的二进制文件装入JVM的方法区，并且在堆区创建描述这个类的java.lang.Class对象。用来封装数据。 但是同一个类只会被类装载器装载以前。 链接就是把二进制数据组装为可以运行的状态。 链接分为校验，准备，解析这3个阶段： 校验一般用来确认此二进制文件是否适合当前的JVM（版本） 准备就是为静态成员分配内存空间。并设置默认值 解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系） 完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收。释放空间。 当没有任何引用指向Class对象时就会被卸载，结束类的生命周期。 案例：将反射用于工厂模式 不用反射的工厂模式 interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } // 构造工厂类 // 也就是说以后如果在添加其它的实例的时候只需要修改工厂类就行了 class Factory{ public static fruit getInstance(String fruitName){ fruit f=null; if(\"Apple\".equals(fruitName)){ f=new Apple(); } if(\"Orange\".equals(fruitName)){ f=new Orange(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.getInstance(\"Orange\"); f.eat(); } } 这样，在添加一个子类的时候，就需要修改工厂类了。如果添加太多的子类的时候，改的就会很多。 利用反射机制的工厂模式 package Reflect; interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } class Factory{ public static fruit getInstance(String ClassName){ fruit f=null; try{ f=(fruit)Class.forName(ClassName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.getInstance(\"Reflect.Apple\"); if(f!=null){ f.eat(); } } } 现在就算添加任意多个子类的时候，工厂类就不需要修改。 上面的代码虽然可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。 结合属性文件的工厂模式 首先创建一个fruit.properties的资源文件，内容为： apple=Reflect.Apple orange=Reflect.Orange 主类代码： package Reflect; import java.io.*; import java.util.*; interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } // 操作属性文件类 class init{ public static Properties getPro() throws FileNotFoundException, IOException{ Properties pro=new Properties(); File f=new File(\"fruit.properties\"); if(f.exists()){ pro.load(new FileInputStream(f)); }else{ pro.setProperty(\"apple\", \"Reflect.Apple\"); pro.setProperty(\"orange\", \"Reflect.Orange\"); pro.store(new FileOutputStream(f), \"FRUIT CLASS\"); } return pro; } } class Factory{ public static fruit getInstance(String ClassName){ fruit f=null; try{ f=(fruit)Class.forName(ClassName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; } } class hello{ public static void main(String[] a) throws FileNotFoundException, IOException{ Properties pro=init.getPro(); fruit f=Factory.getInstance(pro.getProperty(\"apple\")); if(f!=null){ f.eat(); } } } 运行结果： Apple Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p010.html":{"url":"article/p010.html","title":"内存区域和GC机制","keywords":"","body":"内存区域和GC机制 Java垃圾回收概况 Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。 关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。 Java GC机制主要完成3件事：确定哪些内存需要回收，确定什么时候需要执行GC，如何执行GC。经过这么长时间的发展（事实上，在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。 学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。 我们将从4个方面学习Java GC机制： 内存是如何分配的； 如何保证内存不被错误回收（即：哪些内存需要回收）； 在什么情况下执行GC以及执行GC的方式； 如何监控和优化GC机制。 Java内存区域 了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块： 程序计数器（Program Counter Register） 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。 每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。 如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。 虚拟机栈（JVM Stack） 一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。 局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。 虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。 每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。 本地方法栈（Native Method Statck） 本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。 本地方法栈也是线程私有的。 堆区（Heap） 堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。 一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。 关于堆区的内容还有很多，将在下节 Java内存分配机制 中详细介绍。 方法区（Method Area） 在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。 方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。 方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。 在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。 在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。 运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符 \"abc\" 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。 直接内存（Direct Memory） 直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。 Java对象的访问方式 一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。 以最简单的本地变量引用：Object obj = new Object()为例： Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据； new Object()作为实例对象数据存储在堆中； 堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中； 在Java虚拟机规范中，对于通过reference类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种： 通过句柄访问 （图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）： 通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。 通过直接指针访问 （图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》） 通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。 Java内存分配机制 这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。 Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation，也就是方法区）。如下图（来源于成为Java GC专家(1)：深入浅出Java垃圾回收机制）： 年轻代（Young Generation） 对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。 年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为（来源于成为Java GC专家(1)：深入浅出Java垃圾回收机制）： 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快； 最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）； 下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区； 将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区； 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。 从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。 在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread-Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。 年老代（Old Generation） 对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　　 可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。 如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。 可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——“card table”，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。 Java GC机制 GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。 年轻代 事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。 这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）。 由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1。 老年代 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。 方法区（永久代） 永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点： 类的所有实例都已经被回收 加载类的ClassLoader已经被回收 类对象的Class对象没有被引用（即没有通过反射引用该类的地方） 永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制。 -verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息 -verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用 -XX:+TraceClassUnLoading需要fastdebug版HotSpot支持 垃圾收集器 在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）： 在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。 Serial收集器 新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）。 ParNew收集器 新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器 新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效），用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。 Serial Old收集器 老年代收集器，单线程收集器，串行，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。 Parallel Old收集器 老年代收集器，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。 CMS（Concurrent Mark Sweep）收集器 老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。 CMS收集的执行过程 初始标记(CMS-initial-mark)- -> 并发标记(CMS-concurrent-mark) -->预清理(CMS-concurrent-preclean)-->可控预清理(CMS-concurrent-abortable-preclean)--> 重新标记(CMS-remark)- -> 并发清除(CMS-concurrent-sweep)- ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。 具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。 首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集； 如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc； 如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因； 当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象，CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间； 下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿，此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark； 下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间，此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean； 下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间，此阶段涉及几个参数： -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束 -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，即当eden使用达到此值时，才会开始abortable-preclean阶段 -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行 此阶段会打印一些日志如下： CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean， CMS：abort preclean due to time XXX 再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记； YG occupancy：964861K（2403008K），指执行时young代的情况 CMS remark：961330K（1572864K），指执行时old代的情况 此外，还打印出了弱引用处理、类卸载等过程的耗时 再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理 最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构 有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停 A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。 B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。 影响cms gc时长及触发的参数是以下2个： -XX:CMSMaxAbortablePrecleanTime=5000 -XX:CMSInitiatingOccupancyFraction=80 解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大 解决方式： A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间 C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection（cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数 在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。 CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。 还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 G1收集器 在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。 注意并发（Concurrent）和并行（Parallel）的区别： 并发是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行） 并行收集是指多个GC线程并行工作，但此时用户线程是暂停的 所以，Serial是串行的，Parallel收集器是并行的，而CMS收集器是并发的. Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p011.html":{"url":"article/p011.html","title":"成为Java GC专家(1)：深入浅出Java垃圾回收机制","keywords":"","body":"成为Java GC专家(1)：深入浅出Java垃圾回收机制 英文原文 对于Java开发人员来说，了解垃圾回收机制（GC）有哪些好处呢？首先可以满足作为一名软件工程师的求知欲，其次，深入了解GC如何工作可以帮你写出更好的Java应用。 这仅仅代表我个人的意见，但我坚信一个精通GC的人往往是一个好的Java开发者。如果你对GC的处理过程感兴趣，说明你已经具备较大规模应用的开发经验。如果你曾经想过如何正确的选择GC算法，那意味着你已经完全理解你所开发的应用的特点。当然，我们不能以偏概全，这不能作为评价一个好的开发人员的共通标准。但是，我要说的是，深入理解GC是成为一名伟大的程序员的必经之路。 这是成为JavaGC专家系列文章的第一篇，本篇主要针对GC机制进行介绍，在下一篇中，我们将重点探讨分析GC状态以及来自NHN的GC调优的例子。 回到正题，咱们继续谈垃圾回收，在学习GC之前，你首先应该记住一个单词：“stop-the-world”。Stop-the-world会在任何一种GC算法中发生。Stop-the-world意味着 JVM 因为要执行GC而停止了应用程序的执行。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态，直到GC任务完成。GC优化很多时候就是指减少Stop-the-world发生的时间。 按代的垃圾回收机制 在Java程序中不能显式地分配和注销内存。有些人把相关的对象设置为null或者调用System.gc()来试图显式地清理内存。设置为null至少没什么坏处，但是调用System.gc()会显著地影响系统性能，必须彻底杜绝（还好，我还没有见到NHN的哪个开发者调用这个方法）。 在Java中，开发人员无法直接在程序代码中清理内存，而是由垃圾回收器自动寻找不必要的垃圾对象，并且清理掉他们。垃圾回收器会在下面两种假设（hypotheses）成立的情况下被创建（称之为假设不如改为推测（suppositions）或者前提（preconditions））。 大多数对象会很快变得不可达 只有很少的由老对象（创建时间较长的对象）指向新生对象的引用 这些假设我们称之为弱年代假设（ weak generational hypothesis）。为了强化这一假设，HotSpot虚拟机将其物理上划分为两个–新生代（young generation）和老年代（old generation）。 新生代（Young generation）: 绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程我们称之为”minor GC“。 老年代（Old generation）: 对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多。对象从老年代中消失的过程，我们称之为”major GC“（或者”full GC“） 请看下面这个图表。 图1 : GC 空间 & 数据流 上图中的持久代（ permanent generation ）也被称为方法区（method area）。他用来保存类常量以及字符串常量。因此，这个区域不是用来永久的存储那些从老年代存活下来的对象。这个区域也可能发生GC。并且发生在这个区域上的GC事件也会被算为major GC。 有些人可能会问： 如果老年代的对象需要引用一个新生代的对象，会发生什么呢？ 为了解决这个问题，老年代中存在一个”card table“，他是一个512 byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询card table来决定是否可以被收集，而不用查询整个老年代。这个card table由一个write barrier来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但GC的整体时间被显著的减少。 图 2: Card Table 结构 新生代的构成 为了更好地理解GC，我们现在来学习新生代，新生代是用来保存那些第一次被创建的对象，他可以被分为三个空间。 一个伊甸园空间（Eden ） 两个幸存者空间（Survivor ） 一共有三个空间，其中包含两个幸存者空间。每个空间的执行顺序如下： 绝大多数刚刚被创建的对象会存放在伊甸园空间。 在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间。 此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间。 当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。之后会清空已经饱和的那个幸存者空间。 在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。 如果你仔细观察这些步骤就会发现，其中一个幸存者空间必须保持是空的。如果两个幸存者空间都有数据，或者两个空间都是空的，那一定标志着你的系统出现了某种错误。 通过频繁的minor GC将数据移动到老年代的过程可以用下图来描述： 图 3: GC执行前后对比 需要注意的是HotSpot虚拟机使用了两种技术来加快内存分配。他们分别是是”bump-the-pointer“和“TLABs（Thread-Local Allocation Buffers）”。 Bump-the-pointer技术跟踪在伊甸园空间创建的最后一个对象。这个对象会被放在伊甸园空间的顶部。如果之后再需要创建对象，只需要检查伊甸园空间是否有足够的剩余空间。如果有足够的空间，对象就会被创建在伊甸园空间，并且被放置在顶部。这样以来，每次创建新的对象时，只需要检查最后被创建的对象。这将极大地加快内存分配速度。但是，如果我们在多线程的情况下，事情将截然不同。如果想要以线程安全的方式以多线程在伊甸园空间存储对象，不可避免的需要加锁，而这将极大地的影响性能。TLABs 是HotSpot虚拟机针对这一问题的解决方案。该方案为每一个线程在伊甸园空间分配一块独享的空间，这样每个线程只访问他们自己的TLAB空间，再与bump-the-pointer技术结合可以在不加锁的情况下分配内存。 以上是针对新生代空间GC技术的简要介绍，你不需要刻意记住我刚刚提到的两种技术。不知道他们不会对你产生什么影响，但是请务必记住在对象刚刚被创建之后，是保存在伊甸园空间的。那些长期存活的对象会经由幸存者空间转存在老年代空间。 老年代GC处理机制 老年代空间的GC事件基本上是在空间已满时发生，执行的过程根据GC类型不同而不同，因此，了解不同的GC类型将有助于你理解本节的内容。 JDK7一共有5种GC类型： Serial GC Parallel GC Parallel Old GC (Parallel Compacting GC) Concurrent Mark & Sweep GC (or “CMS”) Garbage First (G1) GC 其中，Serial GC不应该被用在服务器上。这种GC类型在单核CPU的桌面电脑时代就存在了。使用Serial GC会显著的降低应用的性能指标。 现在，让我们共同学习每一种GC类型。 Serial GC (-XX:+UseSerialGC) 新生代空间的GC方式我们在前面已经介绍过了，在老年代空间中的GC采取称之为”mark-sweep-compact“的算法。 算法的第一步是标记老年代中依然存活对象。（标记） 第二步，从头开始检查堆内存空间，并且只留下依然幸存的对象。（清理） 最后一步，从头开始，顺序地填满堆内存空间，并且将对内存空间分成两部分：一个保存着对象，另一个空着（压缩）。 Parallel GC (-XX:+UseParallelGC) 图 4: Serial GC 与 Parallel GC的区别 从上图中，你可以轻易地看出serial GC和parallel GC的区别，serial GC只使用一个线程执行GC，而parallel GC使用多个线程，因此parallel GC更高效。这种GC在内存充足以及多核的情况下会很有用，因此我们也称之为”throughput GC“。 Parallel Old GC(-XX:+UseParallelOldGC) Parallel Old GC在JDK5之后出现。与parallel GC相比，唯一的区别在于针对老年代的GC算法。Parallel Old GC分为三步：标记-汇总-压缩（mark – summary – compaction）。汇总（summary）步骤与清理（sweep）的不同之处在于，其将依然幸存的对象分发到GC预先处理好的不同区域，算法相对清理来说略微复杂一点。 CMS GC (-XX:+UseConcMarkSweepGC) 图 5: Serial GC & CMS GC 就像你从上图看到的那样, CMS GC比我之前解释的各种算法都要复杂很多。第一步初始化标记（initial mark） 比较简单。这一步骤只是查找那些距离类加载器最近的幸存对象。因此，停顿的时间非常短暂。在之后的并行标记（ concurrent mark ）步骤，所有被幸存对象引用的对象会被确认是否已经被追踪和校验。这一步的不同之处在于，在标记的过程中，其他的线程依然在执行。在重新标记（remark）步骤，会再次检查那些在并行标记步骤中增加或者删除的与幸存对象引用的对象。最后，在并行交换（ concurrent sweep ）步骤，转交垃圾回收过程处理。垃圾回收工作会在其他线程的执行过程中展开。一旦采取了这种GC类型，由GC导致的暂停时间会极其短暂。CMS GC也被称为低延迟GC。它经常被用在那些对于响应时间要求十分苛刻的应用之上。 当然，这种GC类型在拥有stop-the-world时间很短的优点的同时，也有如下缺点： 它会比其他GC类型占用更多的内存和CPU 默认情况下不支持压缩步骤 在使用这个GC类型之前你需要慎重考虑。如果因为内存碎片过多而导致压缩任务不得不执行，那么stop-the-world的时间要比其他任何GC类型都长，你需要考虑压缩任务的发生频率以及执行时间。 G1 GC 最后，我们来学习垃圾回收优先（G1）GC类型。 图 6: G1 GC的结构 如果你想要理解G1，首先你要忘记你所学过的新生代和老年代的概念。正如你在上图所看到的，每个对象被分配到不同的格子，随后GC执行。当一个区域装满之后，对象被分配到另一个区域，并执行GC。这中间不再有从新生代移动到老年代的三个步骤。这个类型是为了替代CMS GC而被创建的，因为CMS GC在长时间持续运作时会产生很多问题。 G1最大的好处是性能，他比我们在上面讨论过的任何一种GC都要快。但是在JDK 6中，他还只是一个早期试用版本。在JDK7之后才由官方正式发布。就我个人看来，NHN在将JDK 7正式投入商用之前需要很长的一段测试期（至少一年）。因此你可能需要再等一段时间。并且，我也听过几次使用了JDK 6中的G1而导致Java虚拟机宕机的事件。请耐心的等到它更稳定吧。 下一次我将讨论GC优化相关的问题，但是在此之前我要先明确一件事情，假如应用中创建的所有对象的大小和类型都是统一的，那么公司使用的WAS的GC参数可以是相同的。但是WAS所创建对象的大小和生命周期根据服务以及硬件的不同而不同。换句话说，不能因为某个应用使用的GC参数“A”，就说明同样的参数也能给其他服务带来最佳的效果。而是要因地制宜，有的放矢。我们需要找到适合每个WAS线程的参数，并且持续的监控和优化每个设备上的WAS实例。这并不是我的一家之谈，而是负责Oracle Java虚拟机研发的工程师在 JavaOne 2010上已经讨论过的。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p012.html":{"url":"article/p012.html","title":"成为Java GC专家(2)：如何监控Java垃圾回收机制","keywords":"","body":"成为Java GC专家(2)：如何监控Java垃圾回收机制 英文原文 本文是成为Java GC专家系列文章的第二篇。在第一篇《成为Java GC专家(1)：深入浅出Java垃圾回收机制》中我们学习了不同GC算法的执行过程，GC是如何工作的，什么是新生代和老年代，你应该了解的JDK7中的5种GC类型，以及这5种类型对于应用性能的影响。 在本文中，我将解释JVM到底是如何执行垃圾回收处理的。 什么是GC监控？ 垃圾回收收集监控指的是搞清楚JVM如何执行GC的过程，例如，我们可以查明： 何时一个新生代中的对象被移动到老年代时，所花费的时间。 Stop-the-world 何时发生的，持续了多长时间。 GC监控是为了鉴别JVM是否在高效地执行GC，以及是否有必要进行额外的性能调优。基于以上信息，我们可以修改应用程序或者调整GC算法（GC优化）。 如何监控GC 有很多种方法可以监控GC，但其差别仅仅是GC操作通过何种方式展现而已。GC操作是由JVM来完成，而GC监控工具只是将JVM提供的GC信息展现给你，因此，不论你使用何种方式监控GC都将得到相同的结果。所以你也就不必去学习所有的监控GC的方法。但是因为学习每种监控方法不会占用太多时间，了解多一点可以帮助你根据不同的场景选择最为合适的方式。 下面所列的工具以及JVM参数并不适用于所有的HVM供应商。这是因为并没有关于GC信息的强制标准。本文我们将使用HotSpot JVM (Oracle JVM)。因为NHN 一直在使用Oracle (Sun) JVM，所以用它作为示例来解释我们提到的工具和JVM参数更容易些。 首先，GC监控方法根据访问的接口不同，可以分成 CUI 和 GUI 两大类。CUI GC监控方法使用一个独立的叫做”jstat”的CUI应用，或者在启动JVM的时候选择JVM参数”verbosegc”。 GUI GC监控由一个单独的图形化应用来完成，其中三个最常用的应用是”jconsole”, “jvisualvm” 和 “Visual GC”。 下面我们来详细学习每种方法。 jstat jstat 是HotSpot JVM提供的一个监控工具。其他监控工具还有 jps 和 jstatd。有些时候，你可能需要同时使用三种工具来监控你的应用。 jstat 不仅提供GC操作的信息，还提供类装载操作的信息以及运行时编译器操作的信息。本文将只涉及jstat能够提供的信息中与监控GC操作信息相关的功能。 jstat 被放置在$JDK_HOME/bin。因此只要 java 和 javac 能执行，jstat 同样可以执行。 你可以在命令行环境下执行如下语句。 $> jstat –gc $ 1000 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 3008.0 3072.0 0.0 1511.1 343360.0 46383.0 699072.0 283690.2 75392.0 41064.3 2540 18.454 4 1.133 19.588 3008.0 3072.0 0.0 1511.1 343360.0 47530.9 699072.0 283690.2 75392.0 41064.3 2540 18.454 4 1.133 19.588 3008.0 3072.0 0.0 1511.1 343360.0 47793.0 699072.0 283690.2 75392.0 41064.3 2540 18.454 4 1.133 19.588 $> 在上图的例子中，实际的数据会按照如下列输出： S0C S1C S0U S1U EC EU OC OU PC vmid (虚拟机 ID)，正如其名字描述的，它是虚拟机的ID，Java应用不论运行在本地还是远程的机器都会拥有自己独立的vmid。运行在本地机器上的vmid称之为lvmid (本地vmid)，通常是PID。如果想得到PID的值你可以使用ps命令或者Windows任务管理器，但我们推荐使用jps来获取，因为PID和lvmid有时会不一致。jps 通过Java PS实现，jps命令会返回vmids和main方法的信息，正如ps命令展现PIDS和进程名字那样。 首先通过jps命令找到你要监控的Java应用的vmid，并把它作为jstat的参数。当几个WAS实例运行在同一台设备上时，如果你只使用jps命令，将只能看到启动（bootstrap）信息。我们建议在这种情况下使用ps -ef | grep java与jps配合使用。 想要得到GC性能相关的数据需要持续不断地监控，因此在执行jstat时，要规则地输出GC监控的信息。 例如，执行”jstat –gc 1000″ (或 1s)会每隔一秒展示GC监控数据。”jstat –gc 1000 10″会每隔1秒展现一次，且一共10次。 除了-gc之外还有许多选项，其中GC相关的选项如下所示。 参数名称 描述 gc 输出每个堆区域的当前可用空间以及已用空间（伊甸园，幸存者等等），GC执行的总次数，GC操作累计所花费的时间 gccapactiy 输出每个堆区域的最小空间限制（ms）/最大空间限制（mx），当前大小，每个区域之上执行GC的次数。（不输出当前已用空间以及GC执行时间） gccause 输出-gcutil提供的信息以及最后一次执行GC的发生原因和当前所执行的GC的发生原因 gcnew 输出新生代空间的GC性能数据 gcnewcapacity 输出新生代空间的大小的统计数据 gcold 输出老年代空间的GC性能数据 gcoldcapacity 输出老年代空间的大小的统计数据 gcpermcapacity 输出持久带空间的大小的统计数据 gcutil 输出每个堆区域使用占比，以及GC执行的总次数和GC操作所花费的事件 你可以只关心那些最常用的命令，你会经常用到 -gcutil (或-gccause), -gc 和 –gccapacity。 -gcutil 被用于检查堆间的使用情况，GC执行的次数以及GC操作所花费的时间。 -gccapacity 以及其它的参数可以用于检查实际分配内存的大小。 使用 -gc 参数你可以看到如下输出： S0C S1C … GCT 1248.0 896.0 … 1.246 1248.0 896.0 … 1.246 … … … … 不同的jstat参数输出不同类型的列，如下表所示，根据你使用的”jstat option”会输出不同列的信息。 列 说明 Jstat参数 S0C 输出Survivor0空间的大小，单位KB -gc-gccapacity-gcnew-gcnewcapacity S1C 输出Survivor1空间的大小，单位KB -gc-gccapacity-gcnew-gcnewcapacity S0U 输出Survivor0已用空间的大小，单位KB -gc-gcnew S1U 输出Survivor1已用空间的大小，单位KB -gc-gcnew EC 输出Eden空间的大小，单位KB -gc-gccapacity-gcnew-gcnewcapacity EU 输出Eden已用空间的大小，单位KB -gc-gcnew OC 输出老年代空间的大小，单位KB -gc-gccapacity-gcold-gcoldcapacity OU 输出老年代已用空间的大小，单位KB -gc-gcold PC 输出持久代空间的大小，单位KB -gc-gccapacity-gcold-gcoldcapacity-gcpermcapacity PU 输出持久代已用空间的大小，单位KB -gc-gcold YGC 新生代空间GC时间发生的次数 -gc-gccapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause YGCT 新生代GC处理花费的时间 -gc-gcnew-gcutil-gccause FGC full GC发生的次数 -gc-gccapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause FGCT full GC操作花费的时间 -gc-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause GCT GC操作花费的总时间 -gc-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause NGCMN 新生代最小空间容量，单位KB -gccapacity-gcnewcapacity NGCMX 新生代最大空间容量，单位KB -gccapacity-gcnewcapacity NGC 新生代当前空间容量，单位KB -gccapacity-gcnewcapacity OGCMN 老年代最小空间容量，单位KB -gccapacity-gcoldcapacity OGCMX 老年代最大空间容量，单位KB -gccapacity-gcoldcapacity OGC 老年代当前空间容量制，单位KB -gccapacity-gcoldcapacity PGCMN 持久代最小空间容量，单位KB -gccapacity-gcpermcapacity PGCMX 持久代最大空间容量，单位KB -gccapacity-gcpermcapacity PGC 持久代当前空间容量，单位KB -gccapacity-gcpermcapacity PC 持久代当前空间大小，单位KB -gccapacity-gcpermcapacity PU 持久代当前已用空间大小，单位KB -gc-gcold LGCC 最后一次GC发生的原因 -gccause GCC 当前GC发生的原因 -gccause TT 老年化阈值。被移动到老年代之前，在新生代空存活的次数 -gcnew MTT 最大老年化阈值。被移动到老年代之前，在新生代空存活的次数 -gcnew DSS 幸存者区所需空间大小，单位KB -gcnew jstat 的好处是它可以持续的监控GC操作数据，不论Java应用是运行在本地还是远程，只要有控制台的地方就可以使用。当使用–gcutil会输出如下信息。在GC优化的时候，你需要特别注意YGC, YGCT, FGC, FGCT 和GCT。 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 这些信息很重要，因为它们展示了GC处理到底花费了多少时间。 在这个例子中，YGC 是217而 YGCT 是0.928，这样在简单的计算数据平均数后，你可以知道每次新生代的GC大概需要4ms（0.004秒），而full GC的平均时间为33ms。 但是，只看数据平均数经常无法分析出真正的GC问题。这是主要是因为GC操作时间严重的偏差（换句话说，假如两次full GC的时间是 67ms，那么其中的一次full GC可能执行了10ms而另一个可能执行了57ms。）为了更好地检测每次GC处理时间，最好使用 –verbosegc来替代数据平均数。 -verbosegc -verbosegc 是在启动一个Java应用时可以指定的JVM参数之一。而jstat 可以监控任何JVM应用，即便它没有制定任何参数。 -verbosegc 需要在启动的时候指定，因此你可能会认为它没有必要（因为jstat可以替代之）。但是， -verbosegc 会以更浅显易懂的方式展现GC发生的结果，因此他对于监控监控GC信息十分有用。 jstat -verbosegc 监控对象 运行在本机的Java应用可以把日志输出到终端上，或者借助jstatd命令通过网络连接远程的Java应用 只有那些把-verbogc作为启动参数的JVM 输出信息 堆状态（已用空间，最大限制，GC执行次数/时间，等等） 执行GC前后新生代和老年代空间大小，GC执行时间 输出时间 Every designated time 每次设定好的时间 每次GC发生的时候 何时有用 当你试图观察堆空间变化情况 当你试图了解单次GC产生的效果 下面是 -verbosegc 的可用参数 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintGCDateStamps (from JDK 6 update 4) 如果只是用了 -verbosegc。那么默认会加上 -XX:+PrintGCDetails。 –verbosgc 的附加参数并不是独立的。而是经常组合起来使用。 使用 –verbosegc 后，每次GC发生你都会看到如下格式的结果。 [GC [: -> , secs] -> , secs] 收集器 minor gc使用的收集器的名字 starting occupancy1 GC执行前新生代空间大小 ending occupancy1 GC执行后新生代空间大小 pause time1 因为执行minor GC，Java应用暂停的时间 starting occupancy3 GC执行前堆区域总大小 ending occupancy3 GC执行后堆区域总大小 pause time3 Java应用由于执行堆空间GC（包括major GC）而停止的时间 这是 -verbosegc 输出的 minor GC 的例子： S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 这是 Full GC 发生时的例子： [Full GC [Tenured: 3485K->4095K(4096K), 0.1745373 secs] 61244K->7418K(63104K), [Perm : 10756K->10756K(12288K)], 0.1762129 secs] [Times: user=0.19 sys=0.00, real=0.19 secs] 如果使用了 CMS collector，那么如下CMS信息也会被输出。 由于 –verbosegc 参数在每次GC事件发生的时候都会输出日志，我们可以很轻易地观察到GC操作对于堆空间的影响。 (Java) VisualVM + Visual GC Java Visual VM是由Oracle JDK提供的图形化的汇总和监控工具。 图1: VisualVM 截图 除了JDK中自带的版本，你还可以直接从官网下载Visual VM。出于便利性的考虑，JDK中包含的版本被命名为Java VisualVM (jvisualvm),而官网提供的版本被命名为Visual VM (visualvm)。两者的功能基本相同，只有一些细小的差别，例如安装组件的时候。就个人而言，我更喜欢可以从官网下载的Visual VM。 图 2: Viusal GC 安装截图 通过Visual GC，你可以更直观的看到执行 jstatd 所得到的信息。 图3: Visual GC 执行截图 HPJMeter HPJMeter 可以很方便的分析 -verbosegc 输出的结果，如果Visual GC可以视作jstat的图形化版本，那么HPJMeter就相当于 –verbosgc的图形化版本。当然，GC分析只是HPJMeter提供的众多功能之一，HPJMeter是由惠普开发的性能监控工具，他可以支持HP-UX，Linux以及MS Windows。 起初，一个成为 HPTune 被设计用来图形化的分析 -verbosegc。输出的结果。但是，随着HPTune的功能被集成到HPJMeter 3.0版本之后，就没有必要单独下载HPTune了。 但运行一个应用时，-verbosegc 的结果会被输出到一个独立的文件中。 你可以用HPJMeter直接打开这个文件，以便更直观的分析GC性能数据。 图4: HPJMeter 下次预告 本文我们主要讲述了如果监控GC操作信息，这将是GC优化的前提。就我个人经验而言，我推荐使用 jstat 来监控GC操作，如果你感觉到GC操作的执行时间过长，那就可以使用 -verbosegc 参数来分析GC。GC优化的大体步骤就是在添加 -verbosegc 参数后，调整GC参数，分析修改后的结果。在下一篇文章中，我们将通过真实的例子来讲解优化GC的最佳选择。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p013.html":{"url":"article/p013.html","title":"成为Java GC专家(3)：如何优化Java垃圾回收机制","keywords":"","body":"成为Java GC专家(3)：如何优化Java垃圾回收机制 英文原文 本文是成为Java GC专家系列文章的第三篇。在第一篇《成为Java GC专家(1)：深入浅出Java垃圾回收机制》中我们学习了不同GC算法的执行过程，GC是如何工作的，什么是新生代和老年代，你应该了解的JDK7中的5种GC类型，以及这5种类型对于应用性能的影响。 在第二篇《成为Java GC专家(2)：如何监控Java垃圾回收机制》，解释了JVM实际上是如何执行垃圾回收的，我们如何监控GC，以及那哪些具可以让我们的工作更快，更高效。在第三篇文章中，我们会基于实际的例子来解释一些优化GC的最佳实践。我认为在阅读本篇文章之前，你已经很好地理解了之前的文章，因此，为了你能够更好地学习本文，如果你还没有读过之前的两篇文章话，请先阅读。 为什么需要优化GC 或者说的更确切一些，对于基于Java的服务，是否有必要优化GC？应该说，对于所有的基于Java的服务，并不总是需要进行GC优化，但前提是所运行的基于Java的系统，包含了如下参数或行为： 已经通过 -Xms 和 –Xmx 设置了内存大小 包含了 -server 参数 系统中没有超时日志等错误日志 换句话说，如果你没有设定内存的大小，并且系统充斥着大量的超时日志时，你就需要在你的系统中进行GC优化了。 但是，你需要时刻铭记一条：GC优化永远是最后一项任务。 想一下进行GC优化的最根本原因，垃圾收集器清除在Java程序中创建的对象，GC执行的次数即需要被垃圾收集器清理的对象个数，与创建对象的数量成正比，因此，首先你应该减少创建对象的数量。 俗话说的好，“冰冻三尺非一日之寒”。我们应该从小事做起，否则日积月累就会很难管理。 我们需要使用 StringBuilder 或者 StringBuffer 来替代String 应该尽量少的输出日志 但是，我们知道有些情况会让我们束手无策，我们眼睁睁的看着XML以及JSON解析占用了大量的内存。即便我们已经尽可能少的使用 String 以及尽量少的输出日志，大量的临时内存被用于XML或者JSON解析，例如10-100MB。但是，舍弃XML和JSON是很难的。我们只要知道，他会占用很多内存。 如果应用内存使用量经过几次重复调整之后有所改善，你就可以开始GC优化了。 我为GC优化归纳了两个目的： 一个是将转移到老年代的对象数量降到最少 另一个是减少Full GC的执行时间 将转移到老年代的对象数量降到最少 按代的GC机制由Oracle JVM提供，不包括可以在JDK7以及更高版本中使用的G1 GC。换句话说，对象被创建在伊甸园空间，而后转化到幸存者空间，最终剩余的对象被送到老年代。某些比较大的对象会在被创建在伊甸园空间后，直接转移到老年代空间。老年代空间上的GC处理会新生代花费更多的时间。因此，减少被移到老年代对象的数据可以显著地减少Full GC的频率。减少被移到老年代空间的对象的数量，可能被误解为将对象留在新生代。但是，这是不可能的。取而代之，你可以调整新生代空间的大小。 减少Full GC执行时间 Full GC的执行时间比Minor GC要长很多。因此，如果Full GC花费了太多的时间（超过1秒），一些连接的部分可能会发生超时错误。 如果你试图通过消减老年代空间来减少Full GC的执行时间，可能会导致 OutOfMemoryError 或者 Full GC执行的次数会增加。 与之相反，如果你试图通过增加老年代空间来减少Full GC执行次数，执行时间会增加。 因此，你需要将老年代空间设定为一个“合适”的值。 影响GC性能的参数 正如我们在《成为Java GC专家(2)：如何监控Java垃圾回收机制》结尾提到的，不要幻想“某个人设定了GC参数后性能得到极大的提高，我们为什么不和他用一样的参数？”，因为不同的Web服务所创建对象的大小和他们的生命周期都不尽相同。 简单来说，如果一个任务的执行条件是A，B，C，D和E，同样的任务执行条件换为A和B，你会觉得哪个更快？从一般人的直觉来看，在A和B条件下执行的任务会更快。 Java GC参数也是相同的道理，设定一些参数不但没有提高GC执行速度，反而可能导致他更慢。GC优化的最基本原则是将不同的GC参数用于2台或者多台服务器，并进行对比，并将那些被证明提高了性能或者减少了GC执行时间的参数应用于服务器。请谨记这一点。 下面这个表格列出了GC参数中与内存大小相关的，可以影响性能的参数。 表1：GC优化需要考虑的Java参数 定义 参数 描述 堆内存空间 -Xms Heap area size when starting JVM启动JVM时的堆内存空间 -Xmx Maximum heap area size堆内存最大限制 新生代空间 -XX:NewRatio Ratio of New area and Old area新生代和老年代的占比 -XX:NewSize New area size新生代空间 -XX:SurvivorRatio Ratio ofEdenarea and Survivor area伊甸园空间和幸存者空间的占比 我在进行GC优化时经常使用 -Xms，-Xmx和-XX:NewRatio。-Xms 和 -Xmx 是必须的。你如何设定 NewRatio 会对GC性能产生十分显著的影响。 有些人可能会问如何设定Perm区域的大小？你可以通过 -XX:PermSize 和 -XX:MaxPermSize 参数来设定，当 OutOfMemoryError 错误发生并且是由于Perm空间不足导致时。 另一个可能影响GC性能的参数是GC类型。下表列出了所有可选的GC类型（基于JDK6.0） 表2：GC类型可选参数 分类 参数 备考 Serial GC -XX:+UseSerialGC Parallel GC -XX:+UseParallelGC-XX:ParallelGCThreads=value Parallel Compacting GC -XX:+UseParallelOldGC CMS GC -XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+CMSParallelRemarkEnabled-XX:CMSInitiatingOccupancyFraction=value-XX:+UseCMSInitiatingOccupancyOnly G1 -XX:+UnlockExperimentalVMOptions-XX:+UseG1GC 在JDK6中这两个参数必须同时使用 除了G1 GC，可以通过每种类型第一行的参数来切换GC类型。最常用的GC类型是Serial GC。他专门针对客户端系统进行了优化。 影响GC性能的参数有很多，但是上面提到的参数会带来最显著的效果。请牢记，设定过多的参数不一定会减少GC执行时间。 GC优化过程 GC优化的过程与大多数性能改善的过程及其类似。下面是我使用的GC优化过程。 监控GC状态 首先你需要监控GC来检查在系统执行过程中GC的各种状态。请参考前一篇文章中提到的监控方法 《成为Java GC专家(2)：如何监控Java垃圾回收机制》。 在分析监控结果后，决定是否进行GC优化 在检查GC状态的过程中，你应该分析监控结果以便决定是否进行GC优化，如果分析结果表明执行GC的时间只有0.1-0.3秒，那你就没必要浪费时间去进行GC优化。但是，如果GC的执行时间是1-3秒，或者超过10秒，GC将势在必行。 但是，如果你已经为Java分配了10GB的内存，并且不能再减少内存大小，你将无法再对GC进行优化。在进行GC优化之前，你必须想清楚你为什么要分配如此大的内存空间。假如当你分1 GB 或 2 GB内存时出现 OutOfMemoryError ，你应该执行堆内存转储（heap dump），并消除隐患。 注意： 堆内存转储是一个用来检查Java内存中的对象和数据的文件。该文件可以通过执行JDK中的jmap命令来创建。在创建文件的过程中，Java程序会暂停，因此不要再系统执行过程中创建该文件。 你可以在互联网上搜索堆内存[s1] 转储的详细说明。对于韩国的读者，可以参考我去年发布的书： The story of troubleshooting for Java developers and system operators (Sangmin Lee, Hanbit Media, 2011, 416 pages)。 调整GC类型/内存空间 如果你已经决定要进行GC优化，那么就要选择GC类型和设定内存空间。在这时，如果你有几台不同服务器，请时刻牢记，检查每一台服务器的GC参数，并进行有针对性的优化。 分析结果 在调整了GC参数并持续收集24小时之后，开始对结果进行分析，如果你幸运的话，你就找到那些最适合系统的GC参数。反之，你需要通过分析日志来检查内存是如何被分配的。然后你需要通过不断的调整GC类型和内存空间大小一边找到最佳的参数。 如果结果令人满意，你可以将该参数应用于所有的服务器，并停止GC优化 有过GC优化结果令人满意，你可以应用于所有的服务器，下面的章节中，我们将看到每个步骤的具体任务。 监控GC状态及分析结果 查看运行中的Web Application Server (WAS)的GC状态的最佳方法是通过jstat命令，在第二篇文章《成为Java GC专家(2)：如何监控Java垃圾回收机制》中我已经详细解释过jstat命令，因此本篇文章我将重点描述数据部分。 下面这个例子展现了某个JVM在进行GC优化之前的状态。（很遗憾，这不是一个操作服务器） $ jstat -gcutil 21719 1s S0 S1 E O P YGC YGCT FGC FGCT GCT 48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673 48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673 如上表，我们先看一下YGC 和YGCT，计算YGCT/ YGC得到0.050秒（50毫秒）。这意味着新生代空间上的GC操作平均花费50毫秒。在这种情况，你大可不必担心新生代空间上执行的GC操作。 接下来，我们来看一下FGCT 和FGC。，计算FGCT/ FGC得到19.68秒，这意味着GC的平均执行时间为19.68秒，可能是每次花费19.68秒执行了三次，也可能是其中的两次执行了1秒而另一次执行了58秒。不论哪种情况，都需要进行GC优化。 通过 jstat 命令可以很轻易地查看GC状态，但是，分析GC的最佳方式是通过 –verbosegc 参数来生成日志，在之前的文章中我已经解释了如何分析这些日志，HPJMeter 是我个人最喜欢的用于分析 -verbosegc 日志的工具。他很易于使用和分析结果。通过HPJmeter你可以很轻易查看GC执行时间以及GC发生频率。 如果GC执行时间满足下面所有的条件，就意味着无需进行GC优化了。 Minor GC执行的很快（小于50ms） Minor GC执行的并不频繁（大概10秒一次） Full GC执行的很快（小于1s） Full GC执行的并不频繁（10分钟一次） 上面提到的数字并不是绝对的；他们根据服务状态的不同而有所区别，某些服务可能满足于Full GC每次0.9秒的速度，但另一些可能不是。因此，针对不同的服务设定不同的值以决定是否进行GC优化。 在查看GC状态的时候有件事你需要特别注意，那就是不要只关注Minor GC 和Full GC的执行时间。还要关注GC执行的次数，例如，当新生代空间较小时，Minor GC会过于频繁的执行（有时每秒超过1次）。另外，转移到老年代的对象数增多，则会导致Full GC执行次数增多。因此，别忘了加上 –gccapacity 参数来查看具体占用了多少空间。 设定GC类型/内存空间大小 设定GC类型 OracleJVM有5种GC类型，但是在JDK7之前的版本中，只能在Parallel GC, Parallel Compacting GC 和CMS GC之中选择一个，对于选择哪个没有明确的原则和规则。 这样的话，我们该如何选择呢？强烈建议三者都选，但是，有一点是很明确的：CMS GC比Parallel GCs更快。如果真的如此，那么就选CMS GC了。但是，CMS GC也不总是更快。整体来看，CMS GC模式下的Full GC执行更快，不过，一旦出现并行模式失败，他将比Parallel GC更慢。 并发模式失败 我们来详细讲解一下并发模式失败。 Parallel GC 和 CMS GC 最大的不同来自于压缩任务。压缩任务是通过删除已分配内存空间中的空白空间以便压缩内存，清理内存碎片。 在Parallel GC模式下，压缩工作在Full GC执行时进行，这会费很多时间，但是，在执行完Full GC之后，由于能够顺序地分配空间，随后的内存能够被更快的分配。 与之相反的，CMS GC并不进行压缩处理，因此，CMS GC执行的更快。但是，由于没有压缩，在进行磁盘清理之前，内存中会有很多空白空间。这就是说，可能没有足够的空间存储大的对象，例如，虽然老年代空间还有300MB空间，但是一些10MB的对象无法被顺序的存储。在这种情况下，会出现“并行模式失败”警告，并执行压缩处理。在CMS GC模式下，压缩处理的执行时间要比Parallel GCs长很多。另外，这还将导致另外一个问题。关于并发模式失败的详细说明，可以参考Oracle工程师撰写的Understanding CMS GC Logs。 综上所述，你需要找到最适合你的系统的GC类型。 每个系统都有最适合他的GC类型等着你去寻找，如果你有6台服务器。我建议你每两台设置相同的参数。并添加 –verbosegc 参数，分析结果。 设定内存空间大小 下表展示了内存空间大小，GC执行次数以及GC执行时间三者间的关系。 大内存空间 减小GC执行次数 增加GC执行时间 小内存空间 减小GC执行时间 增加GC执行次数 关于如何设置内存空间的大小，没有唯一的标准答案。如果服务器资源足够，而且Full GC也可能在1秒内完成，设置为10GB当然可行。。但绝大多数服务器并不是这样，当内存设为10GB时，可能要花费10~30秒来执行Full GC。当然，执行时间会随对象的大小而改变。 鉴于如此，我们应该如何设定内存空间大小呢？一般来说，我建议为500MB。不过请注意这不是让你将WAS的内存参数设置为 –Xms500m 和 –Xmx500m。根据优化GC之前的状态，如果Full GC执行之后内存空间剩余300MB，那么最好将内存设置为1GB（300MB（默认程序占用）+ 500MB（老年代最小空间）+200MB（空闲内存））。也就是说你要为老年代额外设置500MB。因此，如果你有三个执行服务器，内存分别设置为1GB，1.5GB，2GB，并且检查结果。 理论上来讲，GC执行速度应该遵循1GB> 1.5GB> 2GB,因此1GB执行GC速度最快。但是并不说明1GB空间的Full GC会花费1秒而2GB空间会花费2秒。时间取决于服务器的性能和对象的大小。因此，最佳的方式是建立尽可能多的衡量指标来监控他们。 对于内存空间大小，你应该额外设定 NewRatio 参数。 NewRatio参数是新生代和老年代空间的比例，即 XX:NewRatio=1 意味着新生代与老年代之比为1:1。对于1GB来说就是新生代和老年代各500MB。如果 NewRatio 为2，意味着新生代老年代之比为1:2，因此该值越大，老年代空间越大，新生代空间越小。 这看似一件不是很重要的事情，但 NewRatio 参数会显著地影响整个GC的性能。如果新生代空间很小，会用更多的对象被转移到老年代空间，这样导致频繁的Full GC，增加暂停时间。 你可以简单的认为 NewRatio 为1是最佳的选择，但是，有时可能设置为2或3更好，我就见过很多这样的例子。 如何最快的完成GC优化？对比性能测试的结果应该是最快地方法，为每一台服务器设置不同的参数并监控他们的状态，强烈建议至少监控1或2天的数据。但是，当你对GC优化是，你要确保每次执行相同的负载。并且请求的比率，例如URL都应该是一致的。不过，即便对于专业测试人员要想精确的控制负载也是很难的，并要花费大量的时间准备。因此，相对来说比较方便和容易的方法是调整才参数，之后花费较长的时间收集结果。 分析GC优化结果 在设置了GC参数以及 -verbosegc 参数之后，通过 tail 命令确保日志被正确的生成。如果参数设置的不正确或者日志没有生成，你将白白浪费你的时间。如果日志正确的话，持续收集1到2天。随后最好将日志下载到本地PC并用 HPJMeter 来分析。 Full GC 执行时间 Minor GC执行时间 Full GC 执行间隔 Minor GC 执行间隔 Entire Full GC 执行时间 Entire Minor GC 执行时间 Entire GC 执行时间 Full GC e执行时间 Minor GC 执行时间 找到最佳的GC参数是件非常幸运的事情，然而在大多数场合，我们并不会得到幸运之神的眷顾，在进行GC优化时要尽量小心谨慎，想一步完成优化往往会导致 OutOfMemoryError 。 优化示例 好了，我们一直在纸上谈兵，现在我们看一些实际的GC优化的例子。 示例1 下面这个例子针对 Service S 的优化,对于最近被部署的 Service S，Full GC花费了太长的时间。 请看 jstat –gcutil 的执行结果。 S0 S1 E O P YGC YGCT FGC FGCT GCT 12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993 最左边的 Perm 空间对于最初的GC优化不是很重要，这一次YGC参数的值更加有用。 Minor GC和Full GC的平均值如下表所示。 表3：Service S的Minor GC 和Full GC的平均执行时间 GC 类型 GC 执行次数 GC 执行时间 平均 Minor GC 54 2.047 37 ms Full GC 5 6.946 1,389 s 最重要的是下面两个数据 新生代实际使用空间: 212,992 KB 老年代实际使用空间: 1,884,160 KB 因此，总的内存空间为2GB，不算Perm空间的话，新生代与老年代之比为1:9。通过jstat和 -verbosegc 日志进行数据收集，并把三台服务器按照如下方式设置。 NewRatio=2 NewRatio=3 NewRatio=4 一天之后，检查系统的GC日志后发现，在设置了 NewRatio 参数后很幸运的没有发生Full GC。 为什么？ NewRatio=2: 45 ms NewRatio=3: 34 ms NewRatio=4: 30 ms 我们看到NewRatio=4 是最佳的参数，虽然它的新生代空间最小，但GC时间确最短。设定这个参数之后，系统没有执行过Full GC。 为了说明这个问题，下面是服务之星一段时间后执行 jstat –gcutil 的结果。 S0 S1 E O P YGC YGCT FGC FGCT GCT 8.61 0.00 30.67 24.62 22.38 2424 30.219 0 0.000 30.219 你可能会认为因为服务器接受的请求少才导致的GC执行频率下降。实际上，虽然Full GC没有执行，但是Minor GC被执行了 2,424次。 示例2 这是一个针对ServiceA的例子，我们通过公司内部的应用性能管理系统（APM）发现JVM暂停了相当长的时间（超过8秒），因此我们进行了GC优化。我们找到了Full GC执行时间过长的原因，并着手解决。 进行GC优化的第一步，就是我们添加了 -verbosegc 参数，并得到如下结果。 图1：进行GC优化之前的STW时间 如上图所示，由HPJMeter自动生成的图片之一。X坐标表示JVM执行的时间。Y坐标表示每次GC的时间。CMS绿点，表示Full GC结果。Parallel Scavenge蓝点，表示Minor GC结果。 之前我曾经说过CMS GC是最快的，但是上面的的结果显示出于某种原因，它最多花费了15秒。是什么导致这个结果？是否想起我之前提过的，CMS在进行内存清理时，会变慢。与此同时，服务的内存被设定为 –Xms1g 和 –Xmx4g ，且实际分配了4GB内存。 因此，我将GC类型从CMS改为Parallel GC。并且将内存改为2GB，设定 NewRatio 为3。几小时之后我使用 jstat –gcutil 得到如下结果。 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 30.48 3.31 26.54 37.01 226 11.131 4 11.758 22.890 相对于4GB时的15秒，Full GC变成了平均每次3秒。但是3秒一样比较慢，因此我设计了如下6种场景。 Case 1: -XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=2 Case 2: -XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=3 Case 3: -XX:+UseParallelGC -Xms1g -Xmx1g -XX:NewRatio=3 Case 4: -XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=2 Case 5: -XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=3 Case 6:-XX:+UseParallelOldGC -Xms1g -Xmx1g -XX:NewRatio=3 那一个最快呢？结果显示，内存越小，结果越好。下图展示了Case6的结果。这是GC的性能最好。最长的响应时间只有1.7秒。平均时间在1秒之内。 图2：Case6的时间图表 基于以上结果。我们按照Case6调整了GC参数。但是，这导致了每天晚上都会发生OutOfMemoryError。在这里很难解释具体的原因。简单来说，批处理程序导致了内存泄漏。相关的问题已经被解决。 如果对GC日志只分析很短的时间就贸然对所有服务器进行优化是非常危险的。请时刻牢记，你必须同时分析GC日志和应用程序。 我们回顾了两个关于GC优化的例子，正如我之前提到的，例子中提到的GC参数，可以设置在相同的服务器之上，但前提是他们具有相同的CPU，操作系统，JDK版本以及运行着相同的服务。但是不要直接把我用过的参数用到你的服务至上，它们未必能很好的工作。 结论 我凭借经验进行GC优化，而没有执行堆转储并分析内存的详细内容。精确地分析内存可以得到更好的优化效果。但是，这种分析一般适用于内存使用量相对固定的场合。不过，如果服务严重过载并占用的大量的内存，强力建议根据之前的经验进行GC优化。 我已经在一些服务上设置了G1 GC参数，并进行过性能测试。但还没有应用与正式环境，G1 GC参数的速度要快于其他任何GC类型。但是，你必须要升级到JDK7。另外，他的稳定性也暂时没有保障，没人知道是否会出现致命的错误。因此还不到将其正式应用的时候 在未来的某一天，等到JDK7真正稳定了（这不是说他现在不稳定），并且WAS针对JDK7进行优化后，G1 GC最终能够按照预期的那样工作了，我们可能就不需要在进行GC优化了。 想了解GC优化的更多内容，请登录Slideshare.com查看关联资源。强烈推荐Everything I Ever Learned About JVM Performance Tuning @Twitter。作者Attila Szegedi，一位Twitter工程师。请花些时间阅读。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p014.html":{"url":"article/p014.html","title":"成为Java GC专家(4)：Apache的MaxClients参数详解及其在Tomcat执行FullGC时的影响","keywords":"","body":"成为Java GC专家(4)：Apache的MaxClients参数详解及其在Tomcat执行FullGC时的影响 英文原文 这是“成为Java GC专家系列文章”的第四篇。 在第一篇文章 《成为Java GC专家(1)：深入浅出Java垃圾回收机制》 中我们学习了不同GC算法的执行过程，GC如何工作，新生代及老年代的基本概念，在JDK7中你应该了解的5种GC类型以及他们的性能如何。 在第二篇文章 《成为Java GC专家(2)：如何监控Java垃圾回收机制》 中我们学到了JVM到底是如何执行垃圾回收，我们如何监控GC，以及那些工具可以使得监控过程更高效。 在第三篇文章 《成为Java GC专家(3)：如何优化Java垃圾回收机制》 中我们通过实际的例子学到了一些可以优化GC的参数。同时我们讲解了如何减少对象被转移到老年代空间，如何缩短Full GC时间，以及如何设置GC类型及内存空间。 在第四篇文章中，我们将阐述Apache中MaxClients 参数的重要性，以及他如何在GC发生时，显著地影响整个系统的性能。我将提供几个例子以方便你理解MaxClients 导致的问题。同时我还会说明如何根据系统的内存情况，设置最佳的MaxClients参数值。 MaxClients对于系统的影响 NHN (译者注：NHN是作者工作的公司)服务的执行环境中存在一组Throttle valve-type参数（译者注：节流阀参数，用于控制系统负载）。这些参数对于系统来说十分重要。下面我们看一下Apache的 MaxClients 参数在Full GC 发生时是如何影响系统的。 大部分开发人员都知道在由于GC发生而导致的”停止世界现象(STW) “（详细请参见Understanding Java Garbage Collection）。尤其是，NHN的Java开发人员经常会遇到由于GC原因导致的Tomcat报错。由于Java 虚拟机 (JVM)管理着内存，以Java为基础的程序无法摆脱GC导致的STW现象。假如在某一个时间，当你正在操作你开发的应用时，GC开始执行。即使TTS错误没有发生，你的服务也会给客户展现未预期的503错误。 服务执行环境 由于架构本身的特点，相比较而言纵向扩展，Web服务更适合横向扩展（译者注:增加服务器的数量，而不是提高件配置）。因此，总体来讲，物理设备会根据性能要求被配置成1台Apache+n台Tomcat。但是本文假设我们的环境是1台Apache+一台Tomcat同时安装在一台主机行，如下图所示。 图1：本文假射的服务执行环境 仅供参考，本文描述的参数基于Apache 2.2.21 (prefork MPM)，Tomcat 6.0.35，CentOS 4.72 (32-bit)，jdk 1.6.0_24。 系统可用内存2GB，垃圾收集器使用ParallelOldGC，AdaptiveSizePolicy 采用默认的设置true，堆内存空间600M。 STW 和HTTP 503 让我们假设访问Apache的请求为 200 req/s且有10个httpd进程在运行，另外我们暂时不考虑每个请求的响应时间。在这种前提下，我们假设由于full GC导致的暂停时间为1秒。当Full GC发生的时候Tomcat会怎样？ 第一件进入你脑海的事情应该是Tomcat会因为full GC而停止响应任何请求。在这种情况下，当Tomcat暂停相应请求时Apache会发生什么？ 当Tomcat暂停时，请求会以200 req/s的速度不断的涌入Apache。一般来说，在Full GC发生之前，请求的响应可以快速地被10个或更多的httpd进程处理掉。但是，因为Tomcat暂停了，httpd进程会被不停地创建以相应新进请求。直到超过 httpd.conf 文件中定义 MaxClients 为止。由于默认值为256，Apache不会在乎请求以200 req/s的速度涌入。 这时，新创建的httpd线程将如何呢？ Httpd进程通过d_jk块所管理的空闲的AJP连接，将请求转发给Tomcat。如果没有空闲连接，他会申请创建新的连接。但是，因为Tomcat暂停了，创建新连接的请求会被拒绝。因此这些请求会被存储在backlog队列中，数量的多少取决于rver.xml于AJP Connector的设置。 一旦请求数量超过backlog队列的空间限制。Apache就会返回拒绝连接错误。并且返回HTTP 503错误给用户。 在这种假设条件下，默认的backlog队列空间是100，而请求到达速度是200 req/s。因此，full GC导致的一秒钟的暂停会使得超过100个请求返回503错误。 这样，当Full GC结束后，backlog队列中存储的内容会被Tomcat接受并在通过工作线程处理，线程的最大数量取决于 MaxThreads 的值（默认200）。 MaxClients 与backlog 在这种情况下，设定哪个参数可以避免返回给用户503错误呢？ 首先，我们应该知道backlog的值要够大，以至于能够容纳所有因为Full GC导致暂停期间涌入的请求。换句话说太应该不小于200。 那么，这么设置之后会不会产生新的问题呢？ 让我们假设将backlog设置为200后再重复一下上面的过程。得到的结果比之前更加严重。系统内存使用量一般情况下为50%，但是，在发生Full GC时快速增加到100%，同时导致交换内存空间快速增加，更为严重的是导致Full GC的暂停时间从1秒变成了4秒甚至更多，系统在此期间完全宕机，不能响应任何请求。 在第一种情况下，只有100或更多的请求返回503错误。但是，当我们把backlog调整到200后，超过500个请求会挂起3秒甚至更多地时间无法得到应答 上面这个例子可以很好的说明当你没有完全理解各个设置之间的内在关系时（例如，对于系统的影响），盲目修改系统会导致什么后果。 那么，为什么会产生这个现象呢？ 问题的根源在于 MaxClients 参数的特性。 将 MaxClients 设置为一个很大的值本身没有问题，但最重要的是在设定 MaxClients 参数时，你要确保即使等同于 MaxClients 数量的httpd进程被同时创建，内存使用量也不会超过80%。 系统的内存交换参数一般被设定为60（默认）。因此，当内存使用量超过80%时，就会进行内存交换。 让我们再来看一下为什么这个特性会导致上面那个严重的问题。当请求以200 req/s的速度涌向Tomcat时，Tomcat由于full GC暂停了。此时backlog被设置为200。Apache大约创建100个httpd进程。在这种情况下，一旦内存使用量超过80%，操作系统会激活交换内存区域，并且由于系统认为JVM的老年代中的对象在很长一段时间内未被使用，而将他们移动到交换区域。 最终的结果是，GC使用了内存交换空间，暂停时间剧增。因此httpd进程数进一步增加。从而导致上面描述的内存使用量达到100%的情况。 这两个场合的唯一区别就是backlog的值：100 vs.200。为什么只在200的情况下发生？ 两者不同的原因在于创建的httpd进程的数量。当backlog设置为100时并且Full GC发生时，会创建100个请求的连接并保存在backlog队列中。其他请求得到拒绝连接错误信息并发挥503错误。因此，总的httpd 进程数量仅仅会略高于100。 而当backlog被设置为200时，200个请求会创建连接，因此。总的httpd进程数会多于200。这样超过阀值，从而导致内存交换的发生。 紧接着，不考虑内存使用量而的设定 MaxClients 参数，Full GC导致httpd进程数量暴增，引发内存交换，降低系统性能。 MaxClients参数的计算公式 如果系统的内存使2GB，MaxClients 的值在任何情况下都不应该超过内存的80%（1.6GB），以避免由于内存交换导致的性能下降。换句话说。1.6GB的内存应该共享和分配给Apache，Tomcat以及那些默认被安装的代理程序。 让我们假设代理程序被默认安装在系统，并占用了200m内存，对于Tomcat堆内存的-Xmx 被设定为 600m。因此根据top命令的结果，Tomcat会一直占用725m（Perm Gen + Native Heap Area）。最终Apache可以使用700m内存空间。如下所示。 图2：测试系统的top截屏 如上所述，我们将内存设为700m后MaxClients 应该是多少呢？ 这要取决于加载模块的数量，对于NHN Web服务来说。Apache只是个简单的代理转发，每个httpd线程4m内存（根据top命令的结果）足以（参见图2）。因此。700m内存对应的 MaxClients应该是175。 总结 一个健壮的服务配置至少应该能够降低在服务过载时宕机的时间，在合理的范围内成功的应答请求。针对基于Java的Web服务。你必须检查你的服务在Full GC导致的STW时间内能否稳定的响应请求。 为了响应更多的用户请求和应对DDoS攻击，在没有全面考虑系统内存等因素的情况下，贸然地将 MaxClients设置为一个很大的值，那么它将失去作为阀值的功能，而导致系统出现更严重的问题。 本文提到的情况只会持续3-5秒，因此绝大多数传统的监控工具都无法及时的发现。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p015.html":{"url":"article/p015.html","title":"面向对象的六大原则","keywords":"","body":"面向对象的六大原则 单一职责原则——SRP 开闭原则——OCP 里式替换原则——LSP 依赖倒置原则——DIP 接口隔离原则——ISP 迪米特原则——LOD 单一职责原则SRP(Single Responsibility Principle) 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。 单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。 单一职责原则的好处如下： 可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多 提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。 开放封闭原则OCP(Open－Close Principle) 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。 开闭原则和单一职责原则一样，是非常基础而且一般是常识的原则。开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。 当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。 这个准则和单一职责原则一样，是一个大家都这样去认为但是又没规定具体该如何去做的一种原则。 开闭原则我们可以用一种方式来确保他，我们用抽象去构建框架，用实现扩展细节。这样当发生修改的时候，我们就直接用抽象了派生一个具体类去实现修改。 里式替换原则LSP(the Liskov Substitution Principle LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。 里氏替换原则是一个非常有用的一个概念。他的定义 如果对每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有对象o1都替换成o2的时候，程序P的行为都没有发生变化，那么类型T2是类型T1的子类型。 这样说有点复杂，其实有一个简单的定义 所有引用基类的地方必须能够透明地使用其子类的对象。 里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类可以增加自己独有的方法。 当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。 里氏替换原则之所以这样要求是因为继承有很多缺点，他虽然是复用代码的一种方法，但同时继承在一定程度上违反了封装。父类的属性和方法对子类都是透明的，子类可以随意修改父类的成员。这也导致了，如果需求变更，子类对父类的方法进行一些复写的时候，其他的子类无法正常工作。所以里氏替换法则被提出来。 确保程序遵循里氏替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，然后用实现去扩展细节，这个是不是很耳熟，对，里氏替换原则和开闭原则往往是相互依存的。 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。 依赖倒置原则指的是一种特殊的解耦方式，使得高层次的模块不应该依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。 这也是一个让人难懂的定义，他可以简单来说就是： 高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 在Java 中抽象指的是接口或者抽象类，两者皆不能实例化。而细节就是实现类，也就是实现了接口或者继承了抽象类的类。他是可以被实例化的。高层模块指的是调用端，底层模块是具体的实现类。在Java中，依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的。这就是俗称的面向接口编程。 我们下面有一个例子来讲述这个问题。这个例子是工人用锤子来修理东西。我们的代码如下： public class Hammer { public String function(){ return \"用锤子修理东西\"; } } public class Worker { public void fix(Hammer hammer){ System.out.println(\"工人\" + hammer.function()); } public static void main(String[] args) { new Worker().fix(new Hammer()); } } 这个是一个很简单的例子，但是如果我们要新增加一个功能，工人用 螺丝刀来修理东西，在这个类，我们发现是很难做的。因为我们Worker类依赖于一个具体的实现类Hammer。所以我们用到面向接口编程的思想，改成如下的代码： public interface Tools { public String function(); } 然后我们的Worker是通过这个接口来于其他细节类进行依赖。代码如下： public class Worker { public void fix(Tools tool){ System.out.println(\"工人\" + tool.function()); } public static void main(String[] args) { new Worker().fix(new Hammer()); new Worker().fix(new Screwdriver()); } } 我们的Hammer类与Screwdriver类实现这个接口 public class Hammer implements Tools{ public String function(){ return \"用锤子修理东西\"; } } public class Screwdriver implements Tools{ @Override public String function() { return \"用螺丝刀修理东西\"; } } 这样，通过面向接口编程，我们的代码就有了很高的扩展性，降低了代码之间的耦合度，提高了系统的稳定性。 接口分离原则ISP(the Interface Segregation Principle ISP) 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来 接口隔离原则的定义是 客户端不应该依赖他不需要的接口 换一种说法就是类间的依赖关系应该建立在最小的接口上。这样说好像更难懂。我们通过一个例子来说明。我们知道在Java中一个具体类实现了一个接口，那必然就要实现接口中的所有方法。如果我们有一个类A和类B通过接口I来依赖，类B是对类A依赖的实现，这个接口I有5个方法。但是类A与类B只通过方法1,2,3依赖，然后类C与类D通过接口I来依赖，类D是对类C依赖的实现但是他们却是通过方法1,4,5依赖。那么是必在实现接口的时候，类B就要有实现他不需要的方法4和方法5 而类D就要实现他不需要的方法2，和方法3。这简直就是一个灾难的设计。 所以我们需要对接口进行拆分，就是把接口分成满足依赖关系的最小接口，类B与类D不需要去实现与他们无关接口方法。比如在这个例子中，我们可以把接口拆成3个，第一个是仅仅由方法1的接口，第二个接口是包含2,3方法的，第三个接口是包含4,5方法的。 这样，我们的设计就满足了接口隔离原则。 以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。 迪米特原则LOD(the Law of Demeter LOD) 迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。他的定义： 一个对象应该对其他对象保持最小的了解。 因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。 迪米特法则还有一个更简单的定义 只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 这里我们可以用一个现实生活中的例子来讲解一下。比如我们需要一张CD,我们可能去音像店去问老板有没有我们需要的那张CD，老板说现在没有，等有的时候你们来拿就行了。在这里我们不需要关心老板是从哪里，怎么获得的那张CD，我们只和老板（直接朋友）沟通，至于老板从他的朋友那里通过何种条件得到的CD，我们不关心，我们不和老板的朋友（陌生人）进行通信，这个就是迪米特的一个应用。说白了，就是一种中介的方式。我们通过老板这个中介来和真正提供CD的人发生联系。 总结 到这里，面向对象的六大原则，就写完了。我们看出来，这些原则其实都是应对不断改变的需求。每当需求变化的时候，我们利用这些原则来使我们的代码改动量最小，而且所造成的影响也是最小的。但是我们在看这些原则的时候，我们会发现很多原则并没有提供一种公式化的结论，而即使提供了公式化的结论的原则也只是建议去这样做。这是因为，这些设计原则本来就是从很多实际的代码中提取出来的，他是一个经验化的结论。怎么去用它，用好他，就要依靠设计者的经验。否则一味者去使用设计原则可能会使代码出现过度设计的情况。大多数的原则都是通过提取出抽象和接口来实现，如果发生过度的设计，就会出现很多抽象类和接口，增加了系统的复杂度。让本来很小的项目变得很庞大，当然这也是Java的特性（任何的小项目都会做成中型的项目）。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p016.html":{"url":"article/p016.html","title":"Java集合专题总结","keywords":"","body":"Java集合专题总结 Java 8 对 HashMap 的改进 如果说Java的hashmap是数组+链表，那么JDK 8之后就是数组+链表+红黑树组成了hashmap。之前的实现机制和原理在下面12-12期整理过，这次只说下新加的红黑树机制。 在之前谈过，如果hash算法不好，会使得hash表蜕化为顺序查找，即使负载因子和hash算法优化再多，也无法避免出现链表过长的情景（这个概论虽然很低），于是在JDK1.8中，对hashmap做了优化，引入红黑树。具体原理就是当hash表中每个桶附带的链表长度默认超过8时，链表就转换为红黑树结构，提高HashMap的性能，因为红黑树的增删改是O(logn)，而不是O(n)。 红黑树的具体原理和实现以后再总结。 主要看put方法实现 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 封装了一个final方法，里面用到一个常量，具体用处看源码： static final int TREEIFY_THRESHOLD = 8; 下面是具体源代码注释: final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; // 首先判断hash表是否是空的，如果空，则resize扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 通过key计算得到hash表下标，如果下标处为null， // 就新建链表头结点，在方法最后插入即可 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果下标处已经存在节点，则进入到这里 else { Node e; K k; // 先看hash表该处的头结点是否和key一样 // （hashcode和equals比较），一样就更新 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // hash表头结点和key不一样，则判断节点是不是红黑树， // 是红黑树就按照红黑树处理 else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); // 如果不是红黑树，则按照之前的hashmap原理处理 else { // 遍历链表 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // -1 for 1st (原jdk注释) 显然当链表长度大于等于7的时候， // 也就是说大于8的话，就转化为红黑树结构，针对红黑树进行插入 //（logn复杂度） if (binCount >= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // existing mapping for key if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果超过容量，即扩容 if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } resize是新的扩容方法，之前谈过，扩容原理是使用新的（2倍旧长度）的数组代替，把旧数组的内容放到新数组，需要重新计算hash和计算hash表的位置，非常耗时，但是自从 JDK 1.8 对hashmap 引入了红黑树，它和之前的扩容方法有了改进。 扩容方法的改进 final Node[] resize() { Node[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 如果长度没有超过最大值，则扩容为2倍的关系 else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) // double threshold newThr = oldThr 0) newCap = oldThr; // zero initial threshold signifies using defaults else { newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; table = newTab; // 进行新旧元素的转移过程 if (oldTab != null) { for (int j = 0; j e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode)e).split(this, newTab, j, oldCap); // preserve order（原注释） 如果不是红黑树的情况这里改进了， // 没有rehash的过程，如下分别记录链表的头尾 else { Node loHead = null, loTail = null; Node hiHead = null, hiTail = null; Node next; do { next = e.next; if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 因为有这样一个特点：比如hash表的长度是16，那么15对应二进制是： 0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 扩容之前有两个key，分别是k1和k2： k1的hash： 0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 k2的hash： 0000 0000， 0000 0000， 0000 0000， 0001 1111 = 15 hash值和15模得到： k1：0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 k2：0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 扩容之后表长对应为32，则31二进制： 0000 0000， 0000 0000， 0000 0000， 0001 1111 = 31 重新hash之后得到： k1：0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 k2：0000 0000， 0000 0000， 0000 0000， 0001 1111 = 31 = 15 + 16 观察发现：如果扩容后新增的位是0，那么rehash索引不变，否则才会改变，并且变为原来的索引+旧hash表的长度，故我们只需看原hash表长新增的bit是1还是0，如果是0，索引不变，如果是1，索引变成原索引+旧表长，根本不用像JDK 7 那样rehash，省去了重新计算hash值的时间，而且新增的bit是0还是1可以认为是随机的，因此resize的过程，还能均匀的把之前的冲突节点分散。 故JDK 8对HashMap的优化是非常到位的。 jdk 1.8之前的HashMap实现 Set和List接口是Collection接口的子接口，分别代表无序集合和有序集合，Queue是Java提供的队列实现。 Map用于保存具有key-value映射关系的数据 Java 中有四种常见的Map实现——HashMap, TreeMap, Hashtable和LinkedHashMap： HashMap就是一张hash表，键和值都没有排序。 TreeMap以红黑树结构为基础，键值可以设置按某种顺序排列。 LinkedHashMap保存了插入时的顺序。 Hashtable是同步的(而HashMap是不同步的)。所以如果在线程安全的环境下应该多使用HashMap，而不是Hashtable，因为Hashtable对同步有额外的开销，不过JDK 5之后的版本可以使用conncurrentHashMao代替HashTable。 本文重点总结HashMap，HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 HashMap是非线程安全的，只用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。 HashMap 实现了Serializable接口，因此它支持序列化。 HashMap还实现了Cloneable接口，故能被克隆。 HashMap原理和一些注意点 HashMap的存储结构 紫色部分即代表哈希表本身（其实是一个数组），数组的每个元素都是一个单链表的头节点，链表是用来解决hash地址冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中保存。 HashMap构造方法参数：初始容量和加载因子 这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（默认为16），加载因子是哈希表当前key的数量和容量的比值，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表提前进行 resize 操作（即扩容）。如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），严重浪费。 JDK开发者规定的默认加载因子为0.75，因为这是一个比较理想的值。另外，无论指定初始容量为多少，构造方法都会将实际容量设为不小于指定容量的2的幂次方，且最大值不能超过2的30次方。 HashMap中put、get的源码分析 get方法源码 // 获取key对应的value public V get(Object key) { if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; // 判断key是否相同 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) return e.value; } // 没找到则返回null return null; } // 获取“key为null”的元素的值，HashMap将“key为null”的元素存储在table[0]位置， // 但不一定是该链表的第一个位置！ private V getForNullKey() { for (Entry e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } 首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。 put方法源码 // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; // 将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; } 如果key为null，则将其添加到table[0]对应的链表中，如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，且将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下： // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ >= threshold) resize(2 * table.length); } 注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。 求hash值和索引值的方法 重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列 由hash值找到对应索引的方法如下： static int indexFor(int h, int length) { return h & (length-1); } 因为容量初始还是设定都会转化为2的幂次。故可以使用高效的位与运算替代模运算。下面会解释原因。 计算hash值的方法如下 static int hash(int h) { h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } JDK 的 HashMap 使用了一个 hash 方法对hash值使用位的操作，使hash值的计算效率很高。为什么这样做？主要是因为如果直接使用hashcode值，那么这是一个int值（8个16进制数，共32位），int值的范围正负21亿多，但是hash表没有那么长，一般比如初始16，自然散列地址需要对hash表长度取模运算，得到的余数才是地址下标。假设某个key的hashcode是0AAA0000，hash数组长默认16，如果不经过hash函数处理，该键值对会被存放在hash数组中下标为0处，因为0AAA0000 & (16-1) = 0。过了一会儿又存储另外一个键值对，其key的hashcode是0BBB0000，得到数组下标依然是0，这就说明这是个实现得很差的hash算法，因为hashcode的1位全集中在前16位了，导致算出来的数组下标一直是0。于是明明key相差很大的键值对，却存放在了同一个链表里，导致以后查询起来比较慢（蜕化为了顺序查找）。故JDK的设计者使用hash函数的若干次的移位、异或操作，把hashcode的“1位”变得“松散”，非常巧妙。 几个常见的面试题 说下hashmap的 扩容机制？ 前面说了，hashmap的构造器里指明了两个对于理解HashMap比较重要的两个参数 int initialCapacity, float loadFactor,这两个参数会影响HashMap效率，HashMap底层采用的散列数组实现，利用initialCapacity这个参数我们可以设置这个数组的大小，也就是散列桶的数量，但是如果需要Map的数据过多，在不断的add之后，这些桶可能都会被占满，这是有两种策略，一种是不改变Capacity，因为即使桶占满了，我们还是可以利用每个桶附带的链表增加元素。但是这有个缺点，此时HaspMap就退化成为了LinkedList，使get和put方法的时间开销上升，这是就要采用另一种方法：增加Hash桶的数量，这样get和put的时间开销又回退到近于常数复杂度上。Hashmap就是采用的该方法。 关于扩容。看hashmap的扩容方法，resize方法，它的源码如下： // 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int) (newCapacity * loadFactor); } 很明显，是从新建了一个HashMap的底层数组，长度为原来的两倍，而后调用transfer方法，将旧HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下： // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j e = src[j]; if (e != null) { src[j] = null; do { Entry next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。 hashmap什么时候需要增加容量呢？ 因为效率问题，JDK采用预处理法，这时前面说的loadFactor就派上了用场，当size > initialCapacity * loadFactor，hashmap内部resize方法就被调用，使得重新扩充hash桶的数量，在目前的实现中，是增加一倍，这样就保证当你真正想put新的元素时效率不会明显下降。所以一般情况下HashMap并不存在键值放满的情况。当然并不排除极端情况，比如设置的JVM内存用完了，或者这个HashMap的Capacity已经达到了MAXIMUM_CAPACITY（目前的实现是2^30）。 initialCapacity和loadFactor参数设什么样的值好呢？ initialCapacity的默认值是16，有些人可能会想如果内存足够，是不是可以将initialCapacity设大一些，即使用不了这么大，就可避免扩容导致的效率的下降，反正无论initialCapacity大小，我们使用的get和put方法都是常数复杂度的。这么说没什么不对，但是可能会忽略一点，实际的程序可能不仅仅使用get和put方法，也有可能使用迭代器，如initialCapacity容量较大，那么会使迭代器效率降低。所以理想的情况还是在使用HashMap前估计一下数据量。 加载因子默认值是0.75，是JDK权衡时间和空间效率之后得到的一个相对优良的数值。如果这个值过大，虽然空间利用率是高了，但是对于HashMap中的一些方法的效率就下降了，包括get和put方法，会导致每个hash桶所附加的链表增长，影响存取效率。如果比较小，除了导致空间利用率较低外没有什么坏处，只要有的是内存，毕竟现在大多数人把时间看的比空间重要。但是实际中还是很少有人会将这个值设置的低于0.5。 HashMap的key和value都能为null么？如果k能为null，那么它是怎么样查找值的？ 如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中。 HashMap中put值的时候如果发生了冲突，是怎么处理的？ JDK使用了链地址法，hash表的每个元素又分别链接着一个单链表，元素为头结点，如果不同的key映射到了相同的下标，那么就使用头插法，插入到该元素对应的链表。 HashMap的key是如何散列到hash表的？相比较HashTable有什么改进？ 我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除留余数法），HashTable就是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，且hashtable直接使用了hashcode值，没有重新计算。 HashMap中则通过 h&(length-1) 的方法来代替取模，其中h是key的hash值，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。 接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。 首先，length为2的整数次幂的话，h&(length-1) 在数学上就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率； 其次，length为2的整数次幂的话，则一定为偶数，那么 length-1 一定为奇数，奇数的二进制的最后一位是1，这样便保证了 h&(length-1) 的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀，而如果length为奇数的话，很明显 length-1 为偶数，它的最后一位是0，这样 h&(length-1) 的最后一位肯定为0，即只能为偶数，这样导致了任何hash值都只会被散列到数组的偶数下标位置上，浪费了一半的空间，因此length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。 讨论一下Hashtable HashTable同样是基于哈希表实现的，其实类似HashMap，只不过有些区别，HashTable同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 HashTable比较古老， 是JDK1.0就引入的类，而HashMap 是 1.2 引进的 Map 的一个实现。 HashTable 是线程安全的，能用于多线程环境中。Hashtable同样也实现了Serializable接口，支持序列化，也实现了Cloneable接口，能被克隆。 Hashtable继承于Dictionary类，实现了Map接口。Dictionary是声明了操作\"键值对\"函数接口的抽象类。 有一点注意，HashTable除了线程安全之外（其实是直接在方法上增加了synchronized关键字，比较古老，落后，低效的同步方式），还有就是它的key、value都不为null。另外Hashtable 也有 初始容量 和 加载因子。 public Hashtable() { this(11, 0.75f); } 默认加载因子也是 0.75，HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。因为HashTable是直接使用除留余数法定位地址。且Hashtable计算hash值，直接用key的hashCode()。 还要注意：前面说了Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但如在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。 最后针对扩容：Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 几个常见的笔试，面试题 HashTable和HashMap的区别有哪些？ HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 理解HashMap是Hashtable的轻量级实现（非线程安全的实现，hashtable是非轻量级，线程安全的），都实现Map接口，主要区别在于： 由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。 Hashtable和HashMap扩容的方法不一样，HashTable中hash数组默认大小11，扩容方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数，增加为原来的2倍，没有加1。 两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。 为什么HashMap是线程不安全的，实际会如何体现？ 第一，如果多个线程同时使用put方法添加元素 假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。 第二，如果多个线程同时检测到元素个数超过数组大小*loadFactor 这样会发生多个线程同时对hash数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。且会引起死循环的错误。 能否让HashMap实现线程安全，如何做？ 1、直接使用Hashtable，但是当一个线程访问HashTable的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以，效率很低，现在基本不会选择它了。 2、HashMap可以通过下面的语句进行同步： Collections.synchronizeMap(hashMap); 3、直接使用JDK 5 之后的 ConcurrentHashMap，如果使用Java 5或以上的话，请使用ConcurrentHashMap。 Collections.synchronizeMap(hashMap);又是如何保证了HashMap线程安全？ 直接分析源码吧 // synchronizedMap方法 public static Map synchronizedMap(Map m) { return new SynchronizedMap<>(m); } // SynchronizedMap类 private static class SynchronizedMap implements Map, Serializable { private static final long serialVersionUID = 1978198479659022715L; private final Map m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map m) { this.m = Objects.requireNonNull(m); mutex = this; } SynchronizedMap(Map m, Object mutex) { this.m = m; this.mutex = mutex; } public int size() { synchronized (mutex) {return m.size();} } public boolean isEmpty() { synchronized (mutex) {return m.isEmpty();} } public boolean containsKey(Object key) { synchronized (mutex) {return m.containsKey(key);} } public boolean containsValue(Object value) { synchronized (mutex) {return m.containsValue(value);} } public V get(Object key) { synchronized (mutex) {return m.get(key);} } public V put(K key, V value) { synchronized (mutex) {return m.put(key, value);} } public V remove(Object key) { synchronized (mutex) {return m.remove(key);} } // 省略其他方法 } 从源码中看出 synchronizedMap()方法返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized来保证对Map的操作是线程安全的，故效率其实也不高。 为什么HashTable的默认大小和HashMap不一样？ 前面分析了，Hashtable 的扩容方法是乘2再+1，不是简单的乘2，故hashtable保证了容量永远是奇数，结合之前分析hashmap的重算hash值的逻辑，就明白了，因为在数据分布在等差数据集合(如偶数)上时，如果公差与桶容量有公约数 n，则至少有(n-1)/n 数量的桶是利用不到的，故之前的hashmap 会在取模（使用位与运算代替）哈希前先做一次哈希运算，调整hash值。这里hashtable比较古老，直接使用了除留余数法，那么就需要设置容量起码不是偶数（除（近似）质数求余的分散效果好）。而JDK开发者选了11。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"core_java/grammar/p001.html":{"url":"core_java/grammar/p001.html","title":"面向对象的三大特性","keywords":"","body":"面向对象的三大特性 封装 每个对象包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来进行自己的操作。将方法、属性、字段包装在类中，通过实例化类来生成对象。 封装就像建房子，类就是房子，属性是门窗，字段是房子里的东西，方法是人的行为。属性对字段有保护作用，防止字段被随意的修改或读取。 好的封装能减少耦合 类内部的实现可以自由修改 类具有清晰的对外接口 继承 继承代表一种is-a关系（子类is父类），是面向对象程序设计能够提高软件开发效率的重要原因之一。子类具有（继承）父类的所有特性，也可以定义自己独有的特性。 子类无法直接访问父类的private的属性和方法 子类可以扩展父类没有的属性和方法 子类可以重写父类的方法 继承是具有传递性的 继承来的属性和方法是隐式的 缺点：子类和父类具有强耦合性 多态 多态表示不同的对象可以执行相同的动作，但要通过他们自己的实现代码来执行。比如猫和狗继承自动物，猫叫和狗叫都是相同的动作-动物叫，但是实现方式不同。 子类可以以父类的身份出现 （使用父类对象的地方都可以用子类来代替） 子类在工作时以自己的方式来实现 子类以父类的身份出现时，子类特有的方法和属性不能使用 多态的作用是消除类型之间的耦合关系 多态就是对象拥有多种形态：引用多态和方法多态 引用多态：父类的引用可以指向本类对象、父类的引用可以指向子类的对象 方法多态：创建本类对象时，调用的方法为本类的方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法 存在多态的必要条件：继承、重写、向上转型 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 在Java中有两种形式可以实现多态。继承和接口 基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/grammar/p002.html":{"url":"core_java/grammar/p002.html","title":"面向对象的四大特征","keywords":"","body":"面向对象的四大特征 抽象 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象,二是数据抽象。 继承 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象,这些对象通过一个受保护的接口访问其他对象。 多态性 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"core_java/grammar/p003.html":{"url":"core_java/grammar/p003.html","title":"语句float f=3.4是否正确","keywords":"","body":"语句float f=3.4是否正确 不正确，编译不能通过；精度不准确，应该用强制类型转换。 如下所示： float f=(float)3.4; Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p004.html":{"url":"core_java/grammar/p004.html","title":"语句short s1 = 1; s1 = s1 + 1;是否正确","keywords":"","body":"语句short s1 = 1; s1 = s1 + 1;是否正确 short s1 = 1; s1 = s1 + 1; s1+1运算结果是int型，需要强制转换类型。 short s1 = 1; s1 += 1; 可以正确编译,自动类型提升。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p005.html":{"url":"core_java/grammar/p005.html","title":"Java有没有goto","keywords":"","body":"Java有没有goto goto 是java 中的保留字，现在没有在java 中使用。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p006.html":{"url":"core_java/grammar/p006.html","title":"int 和Integer 有什么区别","keywords":"","body":"int 和Integer 有什么区别 Java 提供两种不同的类型：引用类型和原始类型（或内置类型）； int 是Java的原始数据类型，Integer 是Java为int提供的封装类。 Java 为每个原始类型提供了封装类： 原始类型 封装类型 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而原始类型实例变量的缺省值与它们的类型有关。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p007.html":{"url":"core_java/grammar/p007.html","title":"逻辑操作(&,|,^)与条件操作(&&,||)的区别","keywords":"","body":"逻辑操作(&,|,^)与条件操作(&&,||)的区别 区别主要有两点： 条件操作只能操作布尔型的，而逻辑操作不仅可以操作布尔型，而且可以操作数值型 逻辑操作不会产生短路 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p008.html":{"url":"core_java/grammar/p008.html","title":"Math的floor、round、ceil函数区别","keywords":"","body":"Math的floor、round、ceil函数区别 floor 向下取整，返回不大于的最大整数 ceil 向上取整，则是不小于他的最小整数 round 四舍五入，入的时候是到大于它的整数（当-1.5时，四舍五入后得到的结果不是我们期待的，解决办法是先对他取绝对值，然后在用round方法） round方法，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 正数小数点后大于5则进位；负数小数点后小于以及等于5都舍去，大于5的则进位。 如希望-11.5四舍五入结果为-12，则先对它取绝对值，然后在用round方法，再乘以-1。 示例 Math.floor Math.round Math.ceil 1.4 1 1 2 1.5 1 2 2 1.6 1 2 2 -1.4 -2 -1 -1 -1.5 -2 -1 -1 -1.6 -2 -2 -1 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p009.html":{"url":"core_java/grammar/p009.html","title":"求2*8的最效率方法","keywords":"","body":"求2*8的最效率方法 2 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p010.html":{"url":"core_java/grammar/p010.html","title":"有没有length()这个方法","keywords":"","body":"有没有length()这个方法 数组没有length()这个方法，有length 的属性。 String 有length()这个方法。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p011.html":{"url":"core_java/grammar/p011.html","title":"swtich中表达式的类型","keywords":"","body":"swtich中表达式的类型 int、short、char 或者 byte可以出现在switch中的表达式里。 String类型在 JDK 1.7 之后可以出现在switch中的表达式里。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p012.html":{"url":"core_java/grammar/p012.html","title":"Java中如何跳出多重嵌套循环","keywords":"","body":"Java中如何跳出多重嵌套循环 在最外层循环前加 label 标识,然后用 break:label 方法即可跳出多重循环。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p013.html":{"url":"core_java/grammar/p013.html","title":"构造器Constructor 是否可被override","keywords":"","body":"构造器Constructor 是否可被override 构造器Constructor 不能被继承，因此不能重写Overriding，但可以被重载Overloading。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p014.html":{"url":"core_java/grammar/p014.html","title":"x.equals(y) == true; hashcode是否相同","keywords":"","body":"x.equals(y) == true; hashcode是否相同 相同。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p015.html":{"url":"core_java/grammar/p015.html","title":"是否可以继承String 类","keywords":"","body":"是否可以继承String 类 String 类是final 类，故不可以继承。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p016.html":{"url":"core_java/grammar/p016.html","title":"equals()和equalsIgnoreCase()的区别","keywords":"","body":"equals()和equalsIgnoreCase()的区别 equals()函数 主要是区分“比较的字符串” 大小写和长度时候相同，比较的类型可以是Object类型。 equalsIgnoreCase()函数 比较的参数只能是字符串，这里只要字符串的长度相等，字母的大小写是忽略的。认为A-Z和a-z是一样的。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p017.html":{"url":"core_java/grammar/p017.html","title":"值传递还是引用传递","keywords":"","body":"值传递还是引用传递 问：当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p018.html":{"url":"core_java/grammar/p018.html","title":"char型变量中能否存储一个中文汉字","keywords":"","body":"char型变量中能否存储一个中文汉字 能够定义成为一个中文的，因为Java 中以unicode 编码，一个char 占16个字节，所以放一个中文是没问题的。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p019.html":{"url":"core_java/grammar/p019.html","title":"abstract class和interface有什么区别","keywords":"","body":"abstract class和interface有什么区别 声明方法的存在而不去实现它的类被叫做抽象类（abstract class）。然而可以创建一个变量，其类型是一个抽象类，它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 接口（interface）是抽象类的变体。新型多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，所有成员变量都是publicstatic final 的。一个类可以实现多个接口，当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换， instanceof 运算符可以用来决定某对象的类是否实现了接口。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p020.html":{"url":"core_java/grammar/p020.html","title":"Static Nested Class和Inner Class的不同","keywords":"","body":"Static Nested Class和Inner Class的不同 Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。 而通常的内部类需要在外部类实例化后才能实例化。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p021.html":{"url":"core_java/grammar/p021.html","title":"Java中是否存在内存泄漏","keywords":"","body":"Java中是否存在内存泄漏 内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。但是java中有垃圾回收机制，它能够将不再被使用的对象，自动从内存中清除。 即使这样，java中也存在着内存泄漏的情况： 一：当长生命周期的对象持有短生命周期的对象的引用，就很可能发生内存泄漏。尽管短生命周期的对象已经不再需要，但是长生命周期的对象一直持有它的引用导致其无法被回收。例如，缓存系统；加载一个对象放在缓存系统中，一直不去使用这个对象，但是它一直被缓存引用，所以不会被回收导致缓存泄漏。 检查java中的内存泄漏，一定要将程序各个分支情况都完成执行至结束，然后看其是否被使用过，如果没有才能判定这个对象属于内存泄漏。 二：当一个对象被存储进HashSet集合中，就不可修改这个对象中用于计算哈希值的属性了。否则，对象修改后的哈希值与刚添加进HashSet集合时的哈希值不一样，此时如果将当前对象的引用作为参数，用contains方法判断对象是否存在，则会返回找不到对象的结果。这会导致无法从HashSet单独删除当前对象，造成内存泄漏 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p022.html":{"url":"core_java/grammar/p022.html","title":"静态变量和实例变量的区别","keywords":"","body":"静态变量和实例变量的区别 静态变量也称为类变量，归全类共有，它不依赖于某个对象，可通过类名直接访问；而实例变量必须依存于某一实例，只能通过对象才能访问到它。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p023.html":{"url":"core_java/grammar/p023.html","title":"写clone()方法时通常都有一行代码，是什么","keywords":"","body":"写clone()方法时通常都有一行代码，是什么 Clone 有缺省行为：super.clone();，它负责产生正确大小的空间，并逐位复制。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p024.html":{"url":"core_java/grammar/p024.html","title":"GC 是什么,为什么要有GC","keywords":"","body":"GC 是什么,为什么要有GC GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。 Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() 。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p025.html":{"url":"core_java/grammar/p025.html","title":"垃圾回收的优点和原理","keywords":"","body":"垃圾回收的优点和原理 Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java 程序员在编写程序的时候不再需要考虑内存管理。 由于有垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。 垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p026.html":{"url":"core_java/grammar/p026.html","title":"垃圾回收器的基本原理是什么","keywords":"","body":"垃圾回收器的基本原理是什么 垃圾回收器的基本原理是什么？ 答：对于GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是\"可达的\"，哪些对象是\"不可达的\"。当GC 确定一些对象为\"不可达\"时，GC 就有责任回收这些内存空间。 垃圾回收器可以马上回收内存吗？ 答：可以。 有什么办法主动通知虚拟机进行垃圾回收？ 答：程序员可以手动执行System.gc()，通知GC 运行，但是Java 语言规范并不保证GC 一定会执行。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p027.html":{"url":"core_java/grammar/p027.html","title":"String s=new String(“xyz”);创建了几个String对象","keywords":"","body":"String s=new String(“xyz”);创建了几个String对象 两个对象，一个是\"xyx\",一个是指向\"xyx\"的引用对象s。 上面解释不够详细准确，准确解释可详读《String、StringBuffer、StringBuilder的区别》。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p028.html":{"url":"core_java/grammar/p028.html","title":"接口与抽象类的相互继承问题","keywords":"","body":"接口与抽象类的相互继承问题 接口是否可继承接口? 答：接口可以继承接口。 抽象类是否可实现(implements)接口? 答：抽象类可以实现(implements)接口。 抽象类是否可继承实体类(concrete class)? 答：抽象类可继承实体类，但前提是实体类必须有明确的构造函数。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p029.html":{"url":"core_java/grammar/p029.html","title":"Java的接口和C++的虚类的相同和不同处","keywords":"","body":"Java的接口和C++的虚类的相同和不同处 由于Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static，所有方法默认情况下是public。一个类可以实现多个接口。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p030.html":{"url":"core_java/grammar/p030.html","title":"一个Java源文件中是否可以包含多个类（非内部类）","keywords":"","body":"一个Java源文件中是否可以包含多个类（非内部类） 可以；必须只有一个类名与文件名相同。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p031.html":{"url":"core_java/grammar/p031.html","title":"内部类是否可以引用外部类的成员","keywords":"","body":"内部类是否可以引用外部类的成员 一个内部类对象可以访问创建它的外部类对象的内容。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p032.html":{"url":"core_java/grammar/p032.html","title":"Java中实现多态的机制是什么","keywords":"","body":"Java中实现多态的机制是什么 方法的覆盖Overriding 和重载Overloading 是 Java 多态性的不同表现。 覆盖Overriding 是父类与子类之间多态性的一种表现。 重载Overloading 是一个类中多态性的一种表现。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p033.html":{"url":"core_java/grammar/p033.html","title":"数据类型之间的转换","keywords":"","body":"数据类型之间的转换 如何将数值型字符转换为数字？ 答：调用数值类型相应包装类中的方法parse*(String)或valueOf(String)即可返回相应基本类型或包装类型数值。 如何将数字转换为字符？ 答：将数字与空字符串相加即可获得其所对应的字符串;另外对于基本类型数字还可调用String 类中的valueOf(…)方法返回相应字符串,而对于包装类型数字则可调用其toString()方法获得相应字符串。 如何取小数点前两位并四舍五入? 答：可用该数字构造一java.math.BigDecimal 对象，再利用其round()方法进行四舍五入到保留小数点后两位，再将其转换为字符串截取最后两位。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p034.html":{"url":"core_java/grammar/p034.html","title":"如何实现字符串的反转及替换","keywords":"","body":"如何实现字符串的反转及替换 可用字符串构造一StringBuffer 对象，然后调用StringBuffer 中的 reverse 方法即可实现字符串的反转，调用 replace 方法即可实现字符串的替换。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p035.html":{"url":"core_java/grammar/p035.html","title":"日期和时间","keywords":"","body":"日期和时间 如何取得年月日、小时分秒？ 答：创建java.util.Calendar 实例(Calendar.getInstance())，,调用其get()方法传入不同的参数即可获得参数所对应的值，如： calendar.get(Calendar.YEAR); // 获得年 如何取得从1970 年到现在的毫秒数？ 答：以下方法均可获得该毫秒数: Calendar.getInstance().getTimeInMillis(); System.currentTimeMillis(); 如何取得某个日期是当月的最后一天？ 答：示例代码如下: Calendar time = Calendar.getInstance(); time.set(Calendar.DAY_OF_MONTH, time.getActualMaximum(Calendar.DAY_OF_MONTH)); 如何格式化日期？ 利用java.text.DataFormat 类中的format()方法可将日期格式化。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p036.html":{"url":"core_java/grammar/p036.html","title":"Java和JavaSciprt的区别","keywords":"","body":"Java和JavaSciprt的区别 JavaScript 与Java 是两个公司开发的不同的两个产品。 Java 是SUN 公司推出的新一代面向对象的程序设计语言，特别适合于Internet 应用程序开发；而JavaScript 是Netscape 公司的产品，其目的是为了扩展Netscape Navigator功能,而开发的一种可以嵌入Web 页面中的基于对象和事件驱动的解释性语言,它的前身是Live Script；而Java 的前身是Oak 语言。 下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object Based）和事件驱动（Event Driver）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用； 解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行； 强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型； 代码格式不一样。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/grammar/p037.html":{"url":"core_java/grammar/p037.html","title":"什么时候用assert","keywords":"","body":"什么时候用assert assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion 用于保证程序最基本、关键的正确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion 检查通常是关闭的。 在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个Assertionerror。 断言用于调试目的： assert(a > 0); // throws an Assertionerror if a 断言可以有两种形式： assert Expression1 ; assert Expression1 : Expression2 ; Expression1 应该总是产生一个布尔值。 Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的String 消息。 断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记： javac -source 1.4 Test.java 要在运行时启用断言，可使用-enableassertions 或者-ea 标记。 要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。 要在系统类中启用断言，可使用-esa 或者-dsa 标记。 还可以在包的基础上启用或者禁用断言。 可以在预计正常情况下不会到达的任何位置上放置断言。 断言可以用于验证传递给私有方法的参数。 不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p001.html":{"url":"core_java/exception/p001.html","title":"Java中的异常处理机制的简单原理和应用","keywords":"","body":"Java中的异常处理机制的简单原理和应用 当Java 程序违反了Java 的语义规则时，Java 虚拟机就会将发生的错误表示为一个异常。 违反语义规则包括2 种情况。 一种是Java类库内置的语义检查。例如数组下标越界，会引发IndexOutOfBoundsException；访问null 的对象时会引发NullPointerException。 另一种情况就是Java允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw 关键字引发异常。 所有的异常都是java.lang.Thowable 的子类。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p002.html":{"url":"core_java/exception/p002.html","title":"error和exception有什么区别","keywords":"","body":"error和exception有什么区别 error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况。 exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p003.html":{"url":"core_java/exception/p003.html","title":"try里的return语句与finally代码的执行执行顺序","keywords":"","body":"try里的return语句与finally代码的执行执行顺序 问：try {}里有一个return 语句，那么紧跟在这个try 后的finally {}里的code会不会被执行，什么时候被执行，在return 前还是后? 答：会执行，在return 前执行。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p004.html":{"url":"core_java/exception/p004.html","title":"Java如何进行异常处理及相应关键字含义","keywords":"","body":"Java如何进行异常处理及相应关键字含义 JAVA 语言如何进行异常处理 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。 关键字throws,throw,try,catch,finally分别代表什么意义 Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws 和finally。 一般情况下是用try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。 try 用来指定一块预防所有“异常”的程序 catch 子句紧跟在try 块后面，用来指定你想要捕捉的“异常”的类型 throw 语句用来明确地抛出一个“异常” throws 用来标明一个成员函数可能抛出的各种“异常” finally 为确保一段代码不管发生什么“异常”都被执行一段代码 可以在一个成员函数调用的外面写一个try 语句，在这个成员函数内部写另一个try 语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到堆栈上面，直到所有的try 语句都完成。如果下一级的try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇到有处理这种“异常”的try 语句。 在try 块中可以抛出异常吗 可以。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p005.html":{"url":"core_java/exception/p005.html","title":"运行时异常与一般异常有何异同","keywords":"","body":"运行时异常与一般异常有何异同 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。 Java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p006.html":{"url":"core_java/exception/p006.html","title":"常见的runtime exception","keywords":"","body":"常见的runtime exception 异常 说明 ArithmeticException 算术运算中，被0除或模除 ArrayIndexOutOfBoundsException 数组越界访问 ArrayStoreException 数据存储异常，写数组操作时，对象或数据类型不兼容 ClassCastException 类型转换异常 IllegalArgumentException 方法的参数无效 IllegalThreadStateException 试图非法改变线程状态，比方说试图启动一已经运行的线程 NullPointerException 试图访问一空对象的变量、方法或空数组的元素 NumberFormatException 数据格式异常，试图把一字符串非法转换成数值（或相反） SecurityException 如果Applet试图执行一被WWW浏览器安全设置所禁止的操作 IncompatibleClassChangeException 如改变了某一类定义，却没有重新编译其他引用了这个类的对象。如某一成员变量的声明被从静态改变为非静态，但其他引用了这个变量的类却没有重新编译，或者相反。如删除了类声明中的某一域或方法，但没有重新编译那些引用了这个域或方法的类 OutOfMemoryException 内存不足，通常发生于创建对象之时 NoClassDefFoundException JAVA运行时系统找不到所引用的类 IncompatibleTypeException 试图实例化一个接口，Java运行时系统将抛出这个异常 UnsatisfiedLinkException 如果所需调用的方法是C函数，但Java运行时系统却无法连接这个函数 InternalException 系统内部故障所导致的异常情况，可能是因为Java运行时系统本身的原因。如果发现一可重现的InternalException，可以直接给Sun公司发电邮java@java.Sun.com Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/exception/p007.html":{"url":"core_java/exception/p007.html","title":"final、finally、finalize 的区别","keywords":"","body":"final、finally、finalize 的区别 final：修饰符（关键字）；如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承，因此一个类不能既被声明为abstract的，又被声明为final 的；将变量或方法声明为final，可以保证它们在使用中不被改变；被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改；被声明为final 的方法也同样只能使用，不能重载。 finally：再异常处理时提供finally 块来执行任何清除操作；如果抛出一个异常，那么相匹配的catch 子句就会执行，然后控制就会进入finally 块（如果有的话）。 finalize：方法名；Java 技术允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object 类中定义的，因此所有的类都继承了它。子类覆盖finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"core_java/collection/p001.html":{"url":"core_java/collection/p001.html","title":"介绍Java中的Collection FrameWork","keywords":"","body":"介绍Java中的Collection FrameWork Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p002.html":{"url":"core_java/collection/p002.html","title":"List,Set,Map是否继承自Collection接口","keywords":"","body":"List、Set、Map是否继承自Collection接口 List,Set 是；Map 不是。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p003.html":{"url":"core_java/collection/p003.html","title":"你所知道的集合类都有哪些","keywords":"","body":"你所知道的集合类都有哪些 最常用的集合类是List 和Map。 List 的具体实现包括ArrayList 和Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p004.html":{"url":"core_java/collection/p004.html","title":"ArrayList,Vector,LinkedList的存储性能和特性","keywords":"","body":"ArrayList,Vector,LinkedList的存储性能和特性 ArrayList 和Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p005.html":{"url":"core_java/collection/p005.html","title":"Collection和Collections的区别","keywords":"","body":"Collection和Collections的区别 Collection 是java.util 下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List。 Collections 是个java.util 下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p006.html":{"url":"core_java/collection/p006.html","title":"HashMap和Hashtable的区别","keywords":"","body":"HashMap和Hashtable的区别 二者都实现了Map 接口，是将惟一键映射到特定的值上。 主要区别在于： HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许； HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey,因为contains 方法容易让人引起误解； Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现； Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p007.html":{"url":"core_java/collection/p007.html","title":"Arraylist与Vector区别","keywords":"","body":"Arraylist与Vector区别 就ArrayList 与Vector 主要从二方面来说： 同步性：Vector 是线程安全的（同步），而ArrayList 是线程序不安全的。 数据增长：当需要增长时，Vector 默认增长一倍，而ArrayList 却是一半。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p008.html":{"url":"core_java/collection/p008.html","title":"List,Map,Set存取元素时各有什么特点","keywords":"","body":"List,Map,Set存取元素时各有什么特点 List 以特定次序来持有元素，可有重复元素。 Set 无法拥有重复元素,内部排序。 Map 保存key-value 值，value 可多值。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/collection/p009.html":{"url":"core_java/collection/p009.html","title":"Set里元素用什么方法来区分重复","keywords":"","body":"Set里元素用什么方法来区分重复 Set 里的元素是不能重复的，用equals()方法来区分重复与否。覆盖equals()方法用来判断对象的内容是否相同，而”==”判断地址是否相等，用来决定引用值是否指向同一对象。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"core_java/thread/p001.html":{"url":"core_java/thread/p001.html","title":"sleep()和wait()有什么区别","keywords":"","body":"sleep()和wait()有什么区别 sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep 不会释放对象锁。 wait 是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p002.html":{"url":"core_java/thread/p002.html","title":"请说出你所知道的线程同步的方法","keywords":"","body":"请说出你所知道的线程同步的方法 wait() : 使一个线程处于等待状态，并且释放所持有的对象的lock； sleep() : 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常； notify() : 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM 确定唤醒哪个线程，而且不是按优先级； notityAll() : 唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p003.html":{"url":"core_java/thread/p003.html","title":"多线程和同步分别有几种实现方法","keywords":"","body":"多线程和同步分别有几种实现方法 多线程有两种实现方法，分别是继承Thread 类与实现Runnable 接口。 同步的实现方面有两种，分别是synchronized,wait 与notify。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p004.html":{"url":"core_java/thread/p004.html","title":"同步和异步有何异同以及在何种情况下使用","keywords":"","body":"同步和异步有何异同以及在何种情况下使用 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p005.html":{"url":"core_java/thread/p005.html","title":"启动一个线程是用run()还是start()","keywords":"","body":"启动一个线程是用run()还是start() 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p006.html":{"url":"core_java/thread/p006.html","title":"线程的基本概念、线程的基本状态以及状态之间的关系","keywords":"","body":"线程的基本概念、线程的基本状态以及状态之间的关系 线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身；Java 中的线程有四种状态分别是：运行、就绪、挂起、结束。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p007.html":{"url":"core_java/thread/p007.html","title":"简述synchronized和java.util.concurrent.locks.Lock的异同","keywords":"","body":"简述synchronized和java.util.concurrent.locks.Lock的异同 主要相同点：Lock 能完成synchronized 所实现的所有功能； 主要不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally 从句中释放。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p008.html":{"url":"core_java/thread/p008.html","title":"Java中有几种方法可以实现一个线程","keywords":"","body":"Java中有几种方法可以实现一个线程 有两种实现方法，分别是继承Thread 类与实现Runnable 接口。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/thread/p009.html":{"url":"core_java/thread/p009.html","title":"stop()和suspend()方法为何不推荐使用","keywords":"","body":"stop()和suspend()方法为何不推荐使用 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在； suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。故不应该使用suspend()，而应在自己的Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/io/p001.html":{"url":"core_java/io/p001.html","title":"如何实现Java序列化","keywords":"","body":"如何实现Java序列化 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；序列化的实现：将需要被序列化的类实现Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream 对象的writeObject(Object obj)方法就可以将参数为obj 的对象写出(即保存其状态)，要恢复的话则用输入流。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/io/p002.html":{"url":"core_java/io/p002.html","title":"Java中有几种类型的流，以及对应的抽象类","keywords":"","body":"Java中有几种类型的流，以及对应的抽象类 字节流，字符流。 字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/io/p003.html":{"url":"core_java/io/p003.html","title":"文件和目录（IO）操作","keywords":"","body":"文件和目录（IO）操作 如何列出某个目录下的所有文件？ File file = new File(\"e:\\\\总结\"); File[] files = file.listFiles(); for(int i=0; i 如何列出某个目录下的所有子目录？ File file = new File(\"e:\\\\总结\"); File[] files = file.listFiles(); for(int i=0; i 如何判断一个文件或目录是否存在？ 创建File 对象，调用其exsit()方法即可返回是否存在，如： System.out.println(new File(\"d:\\\\t.txt\").exists()); 如何读写文件？ 读文件: FileInputStream fin = new FileInputStream(\"e:\\\\tt.txt\"); byte[] bs = new byte[100]; while(true){ int len = fin.read(bs); if(len 写文件: FileWriter fw = new FileWriter(\"e:\\\\test.txt\"); fw.write(\"hello world!\" + System.getProperty(\"line.separator\")); fw.write(\"你好！北京！\"); fw.close(); Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/io/p004.html":{"url":"core_java/io/p004.html","title":"统计字符串在文件中出现的次数","keywords":"","body":"统计字符串在文件中出现的次数 public int countWords(String file, String find) throws Exception { int count = 0; Reader in = new FileReader(file); int c; while ((c = in.read()) != -1) { while (c == find.charAt(0)) { for (int i = 1; i Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"core_java/socket/p001.html":{"url":"core_java/socket/p001.html","title":"使用Socket读取服务器字符并本地显示","keywords":"","body":"使用Socket读取服务器字符并本地显示 Server 端程序 package test; import java.net.*; import java.io.*; public class Server{ private ServerSocket ss; private Socket socket; private BufferedReader in; private PrintWriter out; public Server(){ try { ss=new ServerSocket(10000); while(true){ socket = ss.accept(); String RemoteIP = socket.getInetAddress().getHostAddress(); String RemotePort = \":\"+socket.getLocalPort(); System.out.println(\"A client come in!IP:\" + RemoteIP+RemotePort); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = in.readLine(); System.out.println(\"Cleint send is :\" + line); out = new PrintWriter(socket.getOutputStream(),true); out.println(\"Your Message Received!\"); out.close(); in.close(); socket.close(); } } catch (IOException e){ out.println(\"wrong\"); } } public static void main(String[] args){ new Server(); } } Client 端程序 package test; import java.io.*; import java.net.*; public class Client { Socket socket; BufferedReader in; PrintWriter out; public Client(){ try { System.out.println(\"Try to Connect to 127.0.0.1:10000\"); socket = new Socket(\"127.0.0.1\",10000); System.out.println(\"The Server Connected!\"); System.out.println(\"Please enter some Character:\"); BufferedReader line = new BufferedReader(new InputStreamReader(System.in)); out = new PrintWriter(socket.getOutputStream(),true); out.println(line.readLine()); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(in.readLine()); out.close(); in.close(); socket.close(); } catch(IOException e) { out.println(\"Wrong\"); } } public static void main(String[] args) { new Client(); } } Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p001.html":{"url":"jdbc/p001.html","title":"什么是JDBC，在什么时候会用到它","keywords":"","body":"什么是JDBC，在什么时候会用到它 JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。 JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p002.html":{"url":"jdbc/p002.html","title":"有哪些不同类型的JDBC驱动","keywords":"","body":"有哪些不同类型的JDBC驱动 有四类JDBC驱动。和数据库进行交互的Java程序分成两个部分，一部分是JDBC的API，实际工作的驱动则是另一部分。 JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。 Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。 Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。 Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p003.html":{"url":"jdbc/p003.html","title":"JDBC是如何实现Java程序和JDBC驱动的松耦合的","keywords":"","body":"JDBC是如何实现Java程序和JDBC驱动的松耦合的？ JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现。 这是Java核心库里反射机制的最佳实践之一，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。在这里可以看到更多JDBC的使用示例。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p004.html":{"url":"jdbc/p004.html","title":"什么是JDBC连接，在Java中如何创建一个JDBC连接","keywords":"","body":"什么是JDBC连接，在Java中如何创建一个JDBC连接 JDBC连接是和数据库服务器建立的一个会话。你可以想像成是一个和数据库的Socket连接。 创建JDBC连接很简单，只需要两步： 注册并加载驱动：使用Class.forName()，驱动类就会注册到DriverManager里面并加载到内存里。 用DriverManager获取连接对象：调用DriverManager.getConnnection()方法并传入数据库连接的URL，用户名及密码，就能获取到连接对象。 Connection con = null; try{ // load the Driver Class Class.forName(\"com.mysql.jdbc.Driver\"); // create the connection now con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/DBName\", \"username\", \"password\"); }catch (SQLException e) { System.out.println(\"Check database is UP and configs are correct\"); e.printStackTrace(); }catch (ClassNotFoundException e) { System.out.println(\"Please include JDBC MySQL jar in classpath\"); e.printStackTrace(); } } Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p005.html":{"url":"jdbc/p005.html","title":"JDBC的DriverManager是用来做什么的","keywords":"","body":"JDBC的DriverManager是用来做什么的 JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，你可以看下JDBC Driver类的源码来了解一下。 然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p006.html":{"url":"jdbc/p006.html","title":"在Java程序中如何获取数据库服务器的相关信息","keywords":"","body":"在Java程序中如何获取数据库服务器的相关信息 使用DatabaseMetaData可以获取到服务器的信息。当和数据库的连接成功建立了之后，可以通过调用getMetaData()方法来获取数据库的元信息。DatabaseMetaData里面有很多方法，通过它们可以获取到数据库的产品名称，版本号，配置信息等。 DatabaseMetaData metaData = con.getMetaData(); String dbProduct = metaData.getDatabaseProductName(); Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p007.html":{"url":"jdbc/p007.html","title":"JDBC的Statement是什么","keywords":"","body":"JDBC的Statement是什么 Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法我们可以生成一个Statement对象。我们可以通过调用它的execute()，executeQuery()，executeUpdate()方法来执行静态SQL查询。 由于SQL语句是程序中传入的，如果没有对用户输入进行校验的话可能会引起SQL注入的问题，如果想了解更多关于SQL注入的，可以看下这里。 默认情况下，一个Statement同时只能打开一个ResultSet。如果想操作多个ResultSet对象的话，需要创建多个Statement。Statement接口的所有execute方法开始执行时都默认会关闭当前打开的ResultSet。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p008.html":{"url":"jdbc/p008.html","title":"execute，executeQuery，executeUpdate的区别是什么","keywords":"","body":"execute，executeQuery，executeUpdate的区别是什么 Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。 Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。 Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。 只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p009.html":{"url":"jdbc/p009.html","title":"JDBC的PreparedStatement是什么","keywords":"","body":"JDBC的PreparedStatement是什么 PreparedStatement对象代表的是一个预编译的SQL语句。用它提供的setter方法可以传入查询的变量。 由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。由于PreparedStatement自动对特殊字符转义，避免了SQL注入攻击，因此应当尽量的使用它。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p010.html":{"url":"jdbc/p010.html","title":"PreparedStatement中如何注入NULL值","keywords":"","body":"PreparedStatement中如何注入NULL值 可以使用它的setNull方法来把null值绑定到指定的变量上。setNull方法需要传入参数的索引以及SQL字段的类型，像这样： ps.setNull(10, java.sql.Types.INTEGER); Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p011.html":{"url":"jdbc/p011.html","title":"Statement中的getGeneratedKeys方法有什么用","keywords":"","body":"Statement中的getGeneratedKeys方法有什么用 有的时候表会生成主键，这时候就可以用Statement的getGeneratedKeys()方法来获取这个自动生成的主键的值了。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p012.html":{"url":"jdbc/p012.html","title":"相对于Statement，PreparedStatement的优点是什么","keywords":"","body":"相对于Statement，PreparedStatement的优点是什么 它和Statement相比优点在于： PreparedStatement有助于防止SQL注入，因为它会自动对特殊字符转义。 PreparedStatement可以用来进行动态查询。 PreparedStatement执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。 使用PreparedStatement的setter方法更容易写出面向对象的代码，而Statement的话，我们得拼接字符串来生成查询语句。如果参数太多了，字符串拼接看起来会非常丑陋并且容易出错。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p013.html":{"url":"jdbc/p013.html","title":"PreparedStatement的缺点是什么，怎么解决","keywords":"","body":"PreparedStatement的缺点是什么，怎么解决 PreparedStatement的一个缺点是，我们不能直接用它来执行in条件语句；需要执行IN条件语句的话，下面有一些解决方案： 分别进行单条查询——这样做性能很差，不推荐。 使用存储过程——这取决于数据库的实现，不是所有数据库都支持。 动态生成PreparedStatement——这是个好办法，但是不能享受PreparedStatement的缓存带来的好处了。 在PreparedStatement查询中使用NULL值——如果你知道输入变量的最大个数的话，这是个不错的办法，扩展一下还可以支持无限参数。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p014.html":{"url":"jdbc/p014.html","title":"JDBC的ResultSet是什么","keywords":"","body":"JDBC的ResultSet是什么 在查询数据库后会返回一个ResultSet，它就像是查询结果集的一张数据表。 ResultSet对象维护了一个游标，指向当前的数据行。开始的时候这个游标指向的是第一行。如果调用了ResultSet的next()方法游标会下移一行，如果没有更多的数据了，next()方法会返回false。可以在for循环中用它来遍历数据集。 默认的ResultSet是不能更新的，游标也只能往下移。也就是说你只能从第一行到最后一行遍历一遍。不过也可以创建可以回滚或者可更新的ResultSet，像下面这样。 Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); 当生成ResultSet的Statement对象要关闭或者重新执行或是获取下一个ResultSet的时候，ResultSet对象也会自动关闭。 可以通过ResultSet的getter方法，传入列名或者从1开始的序号来获取列数据。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p015.html":{"url":"jdbc/p015.html","title":"有哪些不同的ResultSet","keywords":"","body":"有哪些不同的ResultSet 根据创建Statement时输入参数的不同，会对应不同类型的ResultSet。如果你看下Connection的方法，你会发现createStatement和prepareStatement方法重载了，以支持不同的ResultSet和并发类型。 一共有三种ResultSet对象。 ResultSet.TYPE_FORWARD_ONLY：这是默认的类型，它的游标只能往下移。 ResultSet.TYPE_SCROLL_INSENSITIVE：游标可以上下移动，一旦它创建后，数据库里的数据再发生修改，对它来说是透明的。 ResultSet.TYPE_SCROLL_SENSITIVE：游标可以上下移动，如果生成后数据库还发生了修改操作，它是能够感知到的。 ResultSet有两种并发类型。 ResultSet.CONCUR_READ_ONLY:ResultSet是只读的，这是默认类型。 ResultSet.CONCUR_UPDATABLE:我们可以使用ResultSet的更新方法来更新里面的数据。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p016.html":{"url":"jdbc/p016.html","title":"Statement中的setFetchSize和setMaxRows方法有什么用处","keywords":"","body":"Statement中的setFetchSize和setMaxRows方法有什么用处 setMaxRows可以用来限制返回的数据集的行数。当然通过SQL语句也可以实现这个功能。比如在MySQL中我们可以用LIMIT条件来设置返回结果的最大行数。 setFetchSize理解起来就有点费劲了，因为你得知道Statement和ResultSet是怎么工作的。当数据库在执行一条查询语句时，查询到的数据是在数据库的缓存中维护的。ResultSet其实引用的是数据库中缓存的结果。 假设我们有一条查询返回了100行数据，我们把fetchSize设置成了10，那么数据库驱动每次只会取10条数据，也就是说得取10次。当每条数据需要处理的时间比较长的时候并且返回数据又非常多的时候，这个可选的参数就变得非常有用了。 我们可以通过Statement来设置fetchSize参数，不过它会被ResultSet对象设置进来的值所覆盖掉。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p017.html":{"url":"jdbc/p017.html","title":"如何使用JDBC接口来调用存储过程","keywords":"","body":"如何使用JDBC接口来调用存储过程 存储过程就是数据库编译好的一组SQL语句，可以通过JDBC接口来进行调用。我们可以通过JDBC的CallableStatement接口来在数据库中执行存储过程。初始化CallableStatement的语法是这样的： CallableStatement stmt = con.prepareCall(\"{call insertEmployee(?,?,?,?,?,?)}\"); stmt.setInt(1, id); stmt.setString(2, name); stmt.setString(3, role); stmt.setString(4, city); stmt.setString(5, country); //register the OUT parameter before calling the stored procedure stmt.registerOutParameter(6, java.sql.Types.VARCHAR); stmt.executeUpdate(); 我们得在执行CallableStatement之前注册OUT参数。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p018.html":{"url":"jdbc/p018.html","title":"JDBC的批处理是什么，有什么好处","keywords":"","body":"JDBC的批处理是什么，有什么好处 有时候类似的查询我们需要执行很多遍，比如从CSV文件中加载数据到关系型数据库的表里。我们也知道，执行查询可以用Statement或者PreparedStatement。除此之外，JDBC还提供了批处理的特性，有了它，我们可以在一次数据库调用中执行多条查询语句。 JDBC通过Statement和PreparedStatement中的addBatch和executeBatch方法来支持批处理。 批处理比一条条语句执行的速度要快得多，因为它需要很少的数据库调用。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p019.html":{"url":"jdbc/p019.html","title":"JDBC的事务管理是什么，为什么需要它","keywords":"","body":"JDBC的事务管理是什么，为什么需要它 默认情况下，我们创建的数据库连接，是工作在自动提交的模式下的。这意味着只要我们执行完一条查询语句，就会自动进行提交。因此我们的每条查询，实际上都是一个事务，如果我们执行的是DML或者DDL，每条语句完成的时候，数据库就已经完成修改了。 有的时候我们希望由一组SQL查询组成一个事务，如果它们都执行OK我们再进行提交，如果中途出现异常了，我们可以进行回滚。 JDBC接口提供了一个setAutoCommit(boolean flag)方法，我们可以用它来关闭连接自动提交的特性。我们应该在需要手动提交时才关闭这个特性，不然的话事务不会自动提交，每次都得手动提交。数据库通过表锁来管理事务，这个操作非常消耗资源。因此我们应当完成操作后尽快的提交事务。在这里有更多关于事务的示例程序。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p020.html":{"url":"jdbc/p020.html","title":"如何回滚事务","keywords":"","body":"如何回滚事务 通过Connection对象的rollback方法可以回滚事务。它会回滚这次事务中的所有修改操作，并释放当前连接所持有的数据库锁。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p021.html":{"url":"jdbc/p021.html","title":"JDBC的保存点(Savepoint)是什么，如何使用","keywords":"","body":"JDBC的保存点(Savepoint)是什么，如何使用 有时候事务包含了一组语句，而我们希望回滚到这个事务的某个特定的点。JDBC的保存点可以用来生成事务的一个检查点，使得事务可以回滚到这个检查点。 一旦事务提交或者回滚了，它生成的任何保存点都会自动释放并失效。回滚事务到某个特定的保存点后，这个保存点后所有其它的保存点会自动释放并且失效。可以读下这个了解更多关于JDBC Savepoint的信息。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p022.html":{"url":"jdbc/p022.html","title":"JDBC的DataSource是什么，有什么好处","keywords":"","body":"JDBC的DataSource是什么，有什么好处 DataSource即数据源，它是定义在javax.sql中的一个接口，跟DriverManager相比，它的功能要更强大。我们可以用它来创建数据库连接，当然驱动的实现类会实际去完成这个工作。除了能创建连接外，它还提供了如下的特性： 缓存PreparedStatement以便更快的执行 可以设置连接超时时间 提供日志记录的功能 ResultSet大小的最大阈值设置 通过JNDI的支持，可以为servlet容器提供连接池的功能 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p023.html":{"url":"jdbc/p023.html","title":"如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池","keywords":"","body":"如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池 对部署在servlet容器中的WEB程序而言，创建数据库连接池非常简单，仅需要以下几步。 在容器的配置文件中创建JDBC的JNDI资源，通常在server.xml或者context.xml里面。 在WEB应用程序中，先用InitialContext来查找JNDI资源，然后获取连接。 Context ctx = new InitialContext(); DataSource ds = (DataSource) ctx.lookup(\"java:/comp/env/jdbc/MyLocalDB\"); Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p024.html":{"url":"jdbc/p024.html","title":"Apache的DBCP是什么","keywords":"","body":"Apache的DBCP是什么 如果用DataSource来获取连接的话，通常获取连接的代码和驱动特定的DataSource是紧耦合的。另外，除了选择DataSource的实现类，剩下的代码基本都是一样的。 Apache的DBCP就是用来解决这些问题的，它提供的DataSource实现成为了应用程序和不同JDBC驱动间的一个抽象层。Apache的DBCP库依赖commons-pool库，所以要确保它们都在部署路径下。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p025.html":{"url":"jdbc/p025.html","title":"什么是数据库的隔离级别","keywords":"","body":"什么是数据库的隔离级别 当我们为了数据的一致性使用事务时，数据库系统用锁来防止别人访问事务中用到的数据。数据库通过锁来防止脏读，不可重复读(Non-Repeatable Reads)及幻读（Phantom-Read）的问题。 数据库使用JDBC设置的隔离级别来决定它使用何种锁机制，我们可以通过Connection的getTransactionIsolation和setTransactionIsolation方法来获取和设置数据库的隔离级别。 隔离级别 事务 脏读 不可重复读 幻读 TRANSACTION_NONE 不支持 不可用 不可用 不可用 TRANSACTION_READ_COMMITTED 支持 阻止 允许 允许 TRANSACTION_READ_UNCOMMITTED 支持 允许 允许 允许 TRANSACTION_REPEATABLE_READ 支持 阻止 阻止 允许 TRANSACTION_SERIALIZABLE 支持 阻止 阻止 阻止 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p026.html":{"url":"jdbc/p026.html","title":"JDBC的RowSet是什么，有哪些不同的RowSet","keywords":"","body":"JDBC的RowSet是什么，有哪些不同的RowSet RowSet用于存储查询的数据结果，和ResultSet相比，它更具灵活性。RowSet继承自ResultSet，因此ResultSet能干的，它们也能，而ResultSet做不到的，它们还是可以。RowSet接口定义在javax.sql包里。 RowSet提供的额外的特性有： 提供了Java Bean的功能，可以通过settter和getter方法来设置和获取属性。RowSet使用了JavaBean的事件驱动模型，它可以给注册的组件发送事件通知，比如游标的移动，行的增删改，以及RowSet内容的修改等。 RowSet对象默认是可滚动，可更新的，因此如果数据库系统不支持ResultSet实现类似的功能，可以使用RowSet来实现。 RowSet分为两大类： A. 连接型RowSet——这类对象与数据库进行连接，和ResultSet很类似。JDBC接口只提供了一种连接型RowSet，javax.sql.rowset.JdbcRowSet，它的标准实现是com.sun.rowset.JdbcRowSetImpl。 B. 离线型RowSet——这类对象不需要和数据库进行连接，因此它们更轻量级，更容易序列化。它们适用于在网络间传递数据。 有四种不同的离线型RowSet的实现。 CachedRowSet——可以通过他们获取连接，执行查询并读取ResultSet的数据到RowSet里。我们可以在离线时对数据进行维护和更新，然后重新连接到数据库里，并回写改动的数据。 WebRowSet继承自CachedRowSet——他可以读写XML文档。 JoinRowSet继承自WebRowSet——它不用连接数据库就可以执行SQL的join操作。 FilteredRowSet继承自WebRowSet——我们可以用它来设置过滤规则，这样只有选中的数据才可见。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p027.html":{"url":"jdbc/p027.html","title":"RowSet和ResultSet的区别是什么","keywords":"","body":"RowSet和ResultSet的区别是什么 RowSet继承自ResultSet，因此它有ResultSet的全部功能，同时它自己添加了些额外的特性。RowSet一个最大的好处是它可以是离线的，这样使得它更轻量级，同时便于在网络间进行传输。 具体使用哪个取决于你的需求，不过如果你操作ResultSet对象的时间较长的话，最好选择一个离线的RowSet，这样可以释放数据库连接。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p028.html":{"url":"jdbc/p028.html","title":"常见的JDBC异常有哪些","keywords":"","body":"常见的JDBC异常有哪些 有以下这些： java.sql.SQLException——这是JDBC异常的基类。 java.sql.BatchUpdateException——当批处理操作执行失败的时候可能会抛出这个异常。这取决于具体的JDBC驱动的实现，它也可能直接抛出基类异常java.sql.SQLException。 java.sql.SQLWarning——SQL操作出现的警告信息。 java.sql.DataTruncation——字段值由于某些非正常原因被截断了（不是因为超过对应字段类型的长度限制）。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p029.html":{"url":"jdbc/p029.html","title":"JDBC里的CLOB和BLOB数据类型分别代表什么","keywords":"","body":"JDBC里的CLOB和BLOB数据类型分别代表什么 CLOB意思是Character Large OBjects，字符大对象，它是由单字节字符组成的字符串数据，有自己专门的代码页。这种数据类型适用于存储超长的文本信息，那些可能会超出标准的VARCHAR数据类型长度限制（上限是32KB）的文本。 BLOB是Binary Larget OBject，它是二进制大对象，由二进制数据组成，没有专门的代码页。它能用于存储超过VARBINARY限制（32KB）的二进制数据。这种数据类型适合存储图片，声音，图形，或者其它业务程序特定的数据。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p030.html":{"url":"jdbc/p030.html","title":"JDBC的脏读是什么，哪种数据库隔离级别能防止脏读","keywords":"","body":"JDBC的脏读是什么，哪种数据库隔离级别能防止脏读 当我们使用事务时，有可能会出现这样的情况，有一行数据刚更新，与此同时另一个查询读到了这个刚更新的值。这样就导致了脏读，因为更新的数据还没有进行持久化，更新这行数据的业务可能会进行回滚，这样这个数据就是无效的。 数据库的TRANSACTIONREADCOMMITTED，TRANSACTIONREPEATABLEREAD，和TRANSACTION_SERIALIZABLE隔离级别可以防止脏读。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p031.html":{"url":"jdbc/p031.html","title":"什么是两阶段提交","keywords":"","body":"什么是两阶段提交 当我们在分布式系统上同时使用多个数据库时，这时候我们就需要用到两阶段提交协议。两阶段提交协议能保证是分布式系统提交的原子性。在第一个阶段，事务管理器发所有的事务参与者发送提交的请求。如果所有的参与者都返回OK，它会向参与者正式提交该事务。如果有任何一个参与方返回了中止消息，事务管理器会回滚所有的修改动作。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p032.html":{"url":"jdbc/p032.html","title":"JDBC中存在哪些不同类型的锁","keywords":"","body":"JDBC中存在哪些不同类型的锁 从广义上讲，有两种锁机制来防止多个用户同时操作引起的数据损坏。 乐观锁——只有当更新数据的时候才会锁定记录。 悲观锁——从查询到更新和提交整个过程都会对数据记录进行加锁。 不仅如此，一些数据库系统还提供了行锁，表锁等锁机制。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p033.html":{"url":"jdbc/p033.html","title":"DDL和DML语句分别代表什么","keywords":"","body":"DDL和DML语句分别代表什么 DDL（数据定义语言，Data Definition Language）语句用来定义数据库模式。Create，Alter, Drop, Truncate, Rename都属于DDL语句，一般来说，它们是不返回结果的。 DML（数据操作语言，Data Manipulation Language）语句用来操作数据库中的数据。select, insert, update, delete, call等，都属于DML语句。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p034.html":{"url":"jdbc/p034.html","title":"java.util.Date和java.sql.Date有什么区别","keywords":"","body":"java.util.Date和java.sql.Date有什么区别 java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p035.html":{"url":"jdbc/p035.html","title":"如何把图片或者原始数据插入到数据库中","keywords":"","body":"如何把图片或者原始数据插入到数据库中 可以使用BLOB类型将图片或者原始的二进制数据存储到数据库里。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p036.html":{"url":"jdbc/p036.html","title":"什么是幻读，哪种隔离级别可以防止幻读","keywords":"","body":"什么是幻读，哪种隔离级别可以防止幻读 幻读是指一个事务多次执行一条查询返回的却是不同的值。假设一个事务正根据某个条件进行数据查询，然后另一个事务插入了一行满足这个查询条件的数据。之后这个事务再次执行了这条查询，返回的结果集中会包含刚插入的那条新数据。这行新数据被称为幻行，而这种现象就叫做幻读。 只有TRANSACTION_SERIALIZABLE隔离级别才能防止产生幻读。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p037.html":{"url":"jdbc/p037.html","title":"SQLWarning是什么，在程序中如何获取SQLWarning","keywords":"","body":"SQLWarning是什么，在程序中如何获取SQLWarning SQLWarning是SQLException的子类，通过Connection, Statement, Result的getWarnings方法都可以获取到它。 SQLWarning不会中断查询语句的执行，只是用来提示用户存在相关的警告信息。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p038.html":{"url":"jdbc/p038.html","title":"如果Oracle的存储过程的入参出参中包含数据库对象，应该如何进行调用","keywords":"","body":"如果Oracle的存储过程的入参出参中包含数据库对象，应该如何进行调用 如果Oracle的存储过程的入参出参中包含数据库对象，我们需要在程序创建一个同样大小的对象数组，然后用它来生成Oracle的STRUCT对象。然后可以通过数据库对象的setSTRUCT方法传入这个struct对象，并对它进行使用。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p039.html":{"url":"jdbc/p039.html","title":"如果java.sql.SQLException: No suitable driver found该怎么办","keywords":"","body":"如果java.sql.SQLException: No suitable driver found该怎么办 如果你的SQL URL串格式不正确的话，就会抛出这样的异常。不管是使用DriverManager还是JNDI数据源来创建连接都有可能抛出这种异常。它的异常栈看起来会像下面这样。 org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot create JDBC driver of class 'com.mysql.jdbc.Driver' for connect URL ''jdbc:mysql://localhost:3306/UserDB' at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1452) at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.tomcat.dbcp.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) java.sql.SQLException: No suitable driver found for 'jdbc:mysql://localhost:3306/UserDB at java.sql.DriverManager.getConnection(DriverManager.java:604) at java.sql.DriverManager.getConnection(DriverManager.java:221) at com.journaldev.jdbc.DBConnection.getConnection(DBConnection.java:24) at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:15) Exception in thread \"main\" java.lang.NullPointerException at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:16) 解决这类问题的方法就是，检查下日志文件，像上面的这个日志中，URL串是jdbc:mysql://localhost:3306/UserDB，只要把它改成jdbc:mysql://localhost:3306/UserDB就好了。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p040.html":{"url":"jdbc/p040.html","title":"什么是JDBC的最佳实践","keywords":"","body":"什么是JDBC的最佳实践 下面列举了其中的一些： 数据库资源是非常昂贵的，用完了应该尽快关闭它。Connection, Statement, ResultSet等JDBC对象都有close方法，调用它就好了。 养成在代码中显式关闭掉ResultSet，Statement，Connection的习惯，如果你用的是连接池的话，连接用完后会放回池里，但是没有关闭的ResultSet和Statement就会造成资源泄漏了。 在finally块中关闭资源，保证即便出了异常也能正常关闭。 大量类似的查询应当使用批处理完成。 尽量使用PreparedStatement而不是Statement，以避免SQL注入，同时还能通过预编译和缓存机制提升执行的效率。 如果你要将大量数据读入到ResultSet中，应该合理的设置fetchSize以便提升性能。 你用的数据库可能没有支持所有的隔离级别，用之前先仔细确认下。 数据库隔离级别越高性能越差，确保你的数据库连接设置的隔离级别是最优的。 如果在WEB程序中创建数据库连接，最好通过JNDI使用JDBC的数据源，这样可以对连接进行重用。 如果你需要长时间对ResultSet进行操作的话，尽量使用离线的RowSet。 Everything you need to prepare for your technical interview.modified at 2019-01-23 "},"jdbc/p041.html":{"url":"jdbc/p041.html","title":"JDBC操作数据库的步骤","keywords":"","body":"JDBC操作数据库的步骤 注册数据库驱动。 建立数据库连接。 创建一个Statement。 执行SQL语句。 处理结果集。 关闭数据库连接。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"jdbc/p042.html":{"url":"jdbc/p042.html","title":"数据库连接池工作原理和实现方案","keywords":"","body":"数据库连接池工作原理和实现方案 工作原理：JAVA EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 实现方案：返回的Connection是原始Connection的代理，代理Connection的close方法，当调用close方法时，不是真正关连接，而是把它代理的Connection对象放回到连接池中，等待下一次重复利用。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"jspservlet/p001.html":{"url":"jspservlet/p001.html","title":"说出Servlet 的生命周期，并说出Servlet 和CGI 的区别","keywords":"","body":"说出Servlet 的生命周期，并说出Servlet 和CGI 的区别 Web 容器加载Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其init 方法进行Servlet 的初始化，请求到达时运行其service 方法，service方法自动派遣运行与请求对应的doXXX 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy 方法。与cgi 的区别在于servlet 处于服务器进程中，它通过多线程方式运行其service 方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p002.html":{"url":"jspservlet/p002.html","title":"forward和redirect的区别","keywords":"","body":"forward 和redirect 的区别 forward 是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 redirect 就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request 参数都可以获取，并且从浏览器的地址栏中可以看到跳转后的链接地址。 前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接；在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p003.html":{"url":"jspservlet/p003.html","title":"JSP中动态INCLUDE与静态INCLUDE的区别","keywords":"","body":"JSP 中动态INCLUDE与静态INCLUDE的区别 动态INCLUDE 用jsp:include 动作实现它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。 静态INCLUDE 用include 伪码实现,它不会检查所含文件的变化，适用于包含静态页面。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p004.html":{"url":"jspservlet/p004.html","title":"说出数据连接池的工作机制是什么","keywords":"","body":"说出数据连接池的工作机制是什么 J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p005.html":{"url":"jspservlet/p005.html","title":"JSP的内置对象及方法","keywords":"","body":"JSP的内置对象及方法 request 表示HttpServletRequest 对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header 和session 数据的有用的方法。 response 表示HttpServletResponse 对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）。 out 对象是javax.jsp.JspWriter 的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 pageContext 表示一个javax.servlet.jsp.PageContext 对象。它是用于方便存取各种范围的名字空间、servlet 相关的对象的API，并且包装了通用的servlet 相关功能的方法。 session 表示一个请求的javax.servlet.http.HttpSession 对象。Session可以存贮用户的状态信息。 application 表示一个javax.servle.ServletContext 对象。这有助于查找有关servlet 引擎和servlet 环境的信息。 config 表示一个javax.servlet.ServletConfig 对象。该对象用于存取servlet 实例的初始化参数。page 表示从该页面产生的一个servlet 实例。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p006.html":{"url":"jspservlet/p006.html","title":"JSP有哪些动作，作用分别是什么","keywords":"","body":"JSP有哪些动作，作用分别是什么 JSP 共有以下6 种基本动作： jsp:include：在页面被请求的时候引入一个文件； jsp:useBean：寻找或者实例化一个JavaBean。； jsp:setProperty：设置JavaBean 的属性。； jsp:getProperty：输出某个JavaBean 的属性； jsp:forward：把请求转到一个新的页面； jsp:plugin：根据浏览器类型为Java 插件生成OBJECT 或EMBED 标记。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p007.html":{"url":"jspservlet/p007.html","title":"JSP有哪些内置对象，作用分别是什么","keywords":"","body":"JSP有哪些内置对象，作用分别是什么 JSP 共有以下9 种基本内置组件（可与ASP 的6 种内部组件相对应）： request：用户端请求，此请求会包含来自GET/POST 请求的参数； response：网页传回用户端的回应； pageContext：网页的属性是在这里管理； session：与请求有关的会话期； application：servlet 正在执行的内容； out：用来传送回应的输出； config：servlet 的构架部件； page：JSP 网页本身； exception：针对错误网页，未捕捉的例外。 Everything you need to prepare for your technical interview.modified at 2019-01-25 "},"jspservlet/p008.html":{"url":"jspservlet/p008.html","title":"get和post的区别","keywords":"","body":"get和post的区别 Form 中的get 和post 方法，在数据传输过程中分别对应了HTTP 协议中的GET 和POST 方法。二者主要区别如下： Get 是用来从服务器上获得数据，而Post 是用来向服务器上传递数据； Get 将表单中数据按照variable=value 的形式，添加到action 所指向的URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post 是将表单中的数据放在form 的数据体中，按照变量和值相对应的方式，传递到action所指向URL； Get 是不安全的，因为在传输过程，数据被放在请求的URL 中；Post 的所有操作对用户来说都是不可见的； Get 传输的数据量小，这主要是因为受URL 长度限制；而Post 可以传输大量的数据，所以在上传文件只能使用Post； Get 限制Form 表单的数据集必须为ASCII 字符，而Post 支持整个ISO10646字符集； Get 是Form 的默认方法。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p009.html":{"url":"jspservlet/p009.html","title":"什么情况下调用doGet()和doPost()","keywords":"","body":"什么情况下调用doGet()和doPost() JSP 页面中的form 标签里的method 属性为get 时调用doGet()，为post时调用doPost()。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p010.html":{"url":"jspservlet/p010.html","title":"如何从form表单中得取checkbox的值","keywords":"","body":"如何从form表单中得取checkbox的值 可在页面把checkbox 的name 属性取同一个，value 属性取每个条目的id,后台用getParamter(“name”)能取到checkbox 的一组值。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p011.html":{"url":"jspservlet/p011.html","title":"JSP和Servlet有哪些相同点和不同点","keywords":"","body":"JSP和Servlet有哪些相同点和不同点 JSP 是Servlet 技术的扩展，本质上是Servlet 的简易方式，更强调应用的外表表达。JSP 编译后是\"类servlet\"。Servlet 和JSP 最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML 里分离开来。而JSP 的情况是Java 和HTML 可以组合成一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p012.html":{"url":"jspservlet/p012.html","title":"JSP的四种范围","keywords":"","body":"JSP的四种范围 JSP有四种范围，可以说是四种对象，这四种对象对应不同的作用范围，所以我们说JSP中的四种范围，这四种范围作用域由大到小分别是 page>request>session>application。 利用这四个对象最常用的就是传值，在一个地方设置值，在另一个地方获取值。 这四种范围除了page用pageContext来设置和获取，其它都可以用本对象名来设置和获取。 page：pageContext.setAttribute(\"key\",\"value\")设置变量，pageContext.getAttribute(\"key\",\"value\")获取变量 request：request.setAttribute(\"key\",\"value\")设置变量，request.getAttribute(\"key\",\"value\")获取变量 session：session.setAttribute(\"key\",\"value\")设置变量，session.getAttribute(\"key\",\"value\")获取变量 application：application.setAttribute(\"key\",\"value\")设置变量，application.getAttribute(\"key\",\"value\")获取变量 page： page代表的是当前页面，所以他的范围只是当前页面，在jsp经过编译后的java代码文件中有这么一句，也就是说在jsp页面中this代表的就是page当前页面，一个jsp中有一个page，所以不能通过page在不同页面中传值。 request： request的范围是一次请求，在不同的页面之间可以用request来传值，条件是不可以用重定向，必须要用转发，转发和重定向的区别是：转发在服务器端进行不和用户的客户端发生交互，在服务器的两个页面之间执行转发，用户的浏览器上的网址不发生改变，而重定向是服务器返回给客户端的浏览器，通过浏览器再向服务器发送一次请求，等于和客户端发生了一次交互，浏览器上的网址发生改变。重定向和转发对应的是分贝对应的是两次请求和一次请求。通过实现两个页面之间的转发。 session： session 代表的范围是一次会话，用户初次访问的时候，产生一次会话，当时间超时或者关闭当前会话的时候（关闭当前浏览器，再打开一个浏览器），session失效，在当前会话期间，所有的页面之间是共享的。 application： application 作用域最大，可以理解为一个全局变量，创建之后，只要服务器开启就一直有效，直到服务器关闭。在所有的页面之间共享，即使是再次打开浏览器。所以在程序中不宜创建过多的application，会带来资源上的消耗。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p013.html":{"url":"jspservlet/p013.html","title":"Request对象的主要方法","keywords":"","body":"Request对象的主要方法 方法 说明 setAttribute(String name,Object) 设置名字为name 的属性值 getAttribute(String name) 返回由name 指定的属性值 getAttributeNames() 返回request 对象所有属性的名字集合(枚举) getCookies() 返回客户端的所有Cookie 对象，结果是一个Cookie 数组 getCharacterEncoding() 返回请求中的字符编码方式 getContentLength() 返回请求的Body 的长度 getHeader(String name) 获得HTTP 协议定义的文件头信息 getHeaders(String name) 返回指定名的request Header 的所有值(枚举) getHeaderNames() 返回所有request Header 的名字(枚举) getInputStream() 返回请求的输入流，用于获得请求中的数据 getMethod() 获得客户端向服务器端传送数据的方法 getParameter(String name) 获得客户端请求中传送的name 指定的参数值 getParameterNames() 获得客户端传送给服务器端的所有参数的名字(枚举) getParameterValues(String name) 获得有name 指定的参数的所有值 getProtocol() 获取客户端向服务器端传送数据所依据的协议名称 getQueryString() 获得查询字符串 getRequestURI() 获取发出请求字符串的客户端地址 getRemoteAddr() 获取客户端的IP 地址 getRemoteHost() 获取客户端的名字 getSession([Boolean create]) 返回和请求相关Session getServerName() 获取服务器的名字 getServletPath() 获取客户端所请求的脚本文件的路径 getServerPort() 获取服务器的端口号 removeAttribute(String name) 删除请求中的一个属性 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p014.html":{"url":"jspservlet/p014.html","title":"Servlet执行时一般实现哪几个方法","keywords":"","body":"Servlet执行时一般实现哪几个方法 public void init(ServletConfig config) public ServletConfig getServletConfig() public String getServletInfo() public void service(ServletRequest request,ServletResponse response) public void destroy() Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p015.html":{"url":"jspservlet/p015.html","title":"BS与CS的联系与区别","keywords":"","body":"BS与CS的联系与区别 C/S 是Client/Server 的缩写，是客户机与服务器结构的应用程序，服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix 或SQL Server。客户端需要安装专用的客户端软件。B/Ｓ是Brower/Server 的缩写，是浏览器和服务器结构的应用程序，即Web 应用程序，客户机上只要安装一个浏览器（Browser），如Netscape Navigator 或InternetExplorer，服务器安装Oracle、Sybase、Informix 或SQL Server 等数据库。在这种结构下，用户界面完全通过WWW 浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。 C/S 与B/S 区别 硬件环境不同 C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S 更强的适应范围, 一般只要有操作系统和浏览器就行。 对安全要求不同 C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S 发布部分可公开信息；B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。 对程序架构不同 C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑；B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上.比C/S 有更高的要求B/S 结构的程序架构是发展的趋势, 从MS 的.Net 系列的BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN 和IBM 推的JavaBean 构件技术等,使B/S 更加成熟。 软件重用不同 C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S 要求下的构件的重用性好；B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子。 系统维护不同 C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统；B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 处理问题不同 C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统；B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S 无法作到的. 与操作系统平台关系最小。 用户接口不同 C/S 多是建立的Window 平台上,表现方法有限,对程序员普遍要求较高；B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本。 信息流不同 C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低；B/S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p016.html":{"url":"jspservlet/p016.html","title":"过滤器有哪些作用","keywords":"","body":"过滤器有哪些作用 可以验证客户是否来自可信的网络，可以对客户提交的数据进行重新编码，可以从系统里获得配置的信息，可以过滤掉客户的某些不应该出现的词汇，可以验证用户是否登录，可以验证客户的浏览器是否支持当前的应用，可以记录系统的日志等等。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p017.html":{"url":"jspservlet/p017.html","title":"在JSP中如何使用JavaBeans","keywords":"","body":"在JSP中如何使用JavaBeans 在JSP 中使用JavaBean 常用的动作有： ：用来创建和查找bean 对象； ：用来设置bean 的属性，即调用其setXxx()方法； ：用来获得bean 的属性，即调用其getXxx()方法。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p018.html":{"url":"jspservlet/p018.html","title":"JSP和Servlet中的请求转发分别如何实现","keywords":"","body":"JSP和Servlet中的请求转发分别如何实现 JSP 中的请求转发可利用forward 动作实现：； Serlvet 中实现请求转发的方式为： getServletContext().getRequestDispatcher(path).forward(req,res)。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"jspservlet/p019.html":{"url":"jspservlet/p019.html","title":"JSP标签的作用及如何定义","keywords":"","body":"JSP标签的作用及如何定义 作用： 分离JSP页面的内容和逻辑； 业务逻辑开发者可以创建自定义标签； 封装业务逻辑； 可重用并且易维护； 易于手工修改、易于工具维护； 提供简洁的语法； 定义: 写标签处理器； 写tld 文件； 讲标签处理器和tld 文件放到同一个包里面； 把JSP页面和标签库配置部署在一起。 Everything you need to prepare for your technical interview.modified at 2019-01-26 "},"hibernate/p001.html":{"url":"hibernate/p001.html","title":"进行更新操作时为什么需先获取数据库中原数据","keywords":"","body":"进行更新操作时为什么需先获取数据库中原数据 进行更新操作的时候，为什么一般都是需要先获取到数据库中原数据，然后再把新对象的内容进行复制，然后再执行更新操作呢？比如下面的代码(1)而不是直接代码(2)。 代码（1）内容： // 其中Persion为一个pojo类 // 参数：currentPerson表示从controller层获取到从页面中传递过来的内容 // Service层中： public void updatePerson(Person currentPerson){ //获取到需要修改内容在数据库中原始的内容信息，也就是调用sesssion.load(id)这hibernate方法，也可以是get方法 Person person = personDao.loadPerson（currentPerson.getId()); //将传递过来的对象的属性内容进行复制到获取的对象中 BeanUtil.copyProperties(currentPerson , person); //进行hibernate中的session更新操作 personDao.updatePerson(person); } 代码（2）内容： // 其中Persion为一个pojo类 // 参数：currentPerson表示从controller层获取到从页面中传递过来的内容 // Service层中： public void updatePerson(Person currentPerson){ //进行hibernate中的session更新操作 personDao.updatePersoncurrentPerson) } 解答： 在上面的service层的这个更新的方法中（当然也可以是在controller层或者是strus2的方法中，只是调用的形式有变化而已），注意到了是先获取到数据库中对应的主键id的内容，然后再根据修改的内容进行的更新操作的。 当然，这个问题并不是一定会的，可以说是一种规范吧，就是能够更安全。原因就在于，在hibernate的工作机制中，对应在同一区域（Hibernate缓存区）和时间是不能够有相同主键内容的数据存在的，也就是说不能有两个相同主键的持久化类存在。 更为通俗的讲解就是，如果当前需要更新的实体，刚好的主键id对应着Hibernate缓存区中，已经存在了，那么这样就会报一个different object with the same identitifer的错误，很明显就是说存在了相同id的两个持久化类了，所以，通过先拿到当前修改id的原始内容，然后进行修改属性内容之后，再把改对象放入到更新操作中，就相当于从hibernate缓存区先取出已经存在的，然后修改了，再放回去，这样就肯定保证了只会存在一个唯一了，所以就防止不会出现上述的这个错误了。 当然，如果不进行先获取，再保存也可以，只是这样增加了安全性，所以记住，如果进行修改操作，那么就需要这样的步骤才是最安全的。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p002.html":{"url":"hibernate/p002.html","title":"解决Hibernate懒加载load出现no session的错误","keywords":"","body":"解决Hibernate懒加载load出现no session的错误 这个问题其实是开发中，很经过会遇到的一个问题。之所以出现这样的问题是在于，session对象当执行了相应的crud操作之后，就会结束生命周期了，而当session接受之后，然后又访问刚获取到的对象的相应的内容，那么因为是load（）方法是进行懒加载，当真正进行使用该对象的时候，再会真正的去获取，而此时session对象已经关闭了，所以肯定就会出现上面的问题了。就代码解释就是如下的代码： // 其中Persion为一个pojo类 // 参数：id表示从要进行获取到主键id // Dao层中： public void loadOpPerson(Long id){ Person person = this.hibernateTemplate.load(Person.class , id); person.getName(); //执行到这就会报no session的错误 } 原理上面，我解释过了，所以，来说一下如何解决这个问题，其实很好解决，那就是扩大session的生命周期，这样不就可以么吗？所以就可以采取在web.xml中配置一个OpenSessionInViewFilter过滤器，具体代码如下： OpenSessionInViewFilter org.springframework.orm.hibernate3.support.OpenSessionInViewFilter OpenSessionInViewFilter *.action 注意，这个一定要配置在strus2的核心过滤器前面（如果采取的是strus2的框架，如果用的springmvc那么同理）。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p003.html":{"url":"hibernate/p003.html","title":"解决Hibernate中并发所引起的数据库内容读取问题","keywords":"","body":"解决Hibernate中并发所引起的数据库内容读取问题 对于这个问题中，是非常常见的，但是Hibernate提供了很好的支持，就是通过锁机制，这就可以采取悲观锁与乐观锁的机制来解决这个问题。 悲观锁 —— 锁的粒度为数据库 悲观锁，它是对数据库而言的，数据库悲观了，他感觉每一个对他操作的程序都有可能产生并发。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 首先说一条SQL语句如下： select * from student where name=\"xiaoming\" for update 其实这就是一个非常依赖于数据库的悲观锁的使用，同理，Hibernate之所以也能够这样，也就是通过数据库中的锁机制来实现的。代码如下： String hqlStr =\"from Student s where s.name='xiaoming'\"; Query query = session.createQuery(hqlStr); query.setLockMode(\"s\",LockMode.UPGRADE); // 加锁 List userList = query.list();// 执行查询，获取数据 这里Hibernate通过使用数据库的 for update子句实现了悲观锁机制。 Hibernate的加锁模式有： LockMode.NONE ：无锁机制。 LockMode.WRITE ：Hibernate在 Insert和 Update记录的时候会自动获取。 LockMode.READ ：Hibernate在读取记录的时候会自动获取。 以上这三种锁机制一般由 Hibernate内部使用，如Hibernate为了保证 Update过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE锁。 LockMode.UPGRADE ：利用数据库的 for update 子句加锁。 LockMode. UPGRADE_NOWAIT ： Oracle的特定实现，利用 Oracle的 for update nowait子句实现加锁。 上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： Criteria.setLockMode Query.setLockMode Session.lock 注意，只有在查询开始之前（也就是 Hiberate生成 SQL之前）设定加锁，才会真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含 for update子句的 Select SQL加载进来，所谓数据库加锁也就无从谈起。 乐观锁 —— 锁的粒度为表，而且当出现了问题之后，才采取措施 乐观锁，从名字来看，就肯定比悲观锁有着更为乐观的态度了，就是说悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个\"version\"字段来实现。 乐观锁的工作原理：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 Hibernate为乐观锁提供了三 种实现： 基于version —— 最常用 基于timestamp —— 较常用 为遗留项目添加乐观锁 —— 不常用 基于version的使用 （1）对需要进行锁控制的数据库表中，添加一个字段，名字随便，一般就叫version，类型只有为long,integer,short,timestamp,calendar，也就是只能为数字或timestamp类型。 （2）如果通过配置文件进行配置的hibernate映射文件，那么就在对应的实体映射文件中添加如下代码： 如果是通过注解的形式进行的hibernate实体配置，那么很简单，只需要在对应的version字段用注解@version，即可，是不是简单很多呢？ （3）在POJO实体类中，实现对于version字段的set（）和get（）方法，这个和普通的属性一样，都需要这两个方法。 基于timestamp 这个使用一样，只是需要把映射文件中的标签改一下即可， 好了，下面就用一个test例子来验证一下是否有锁控制机制。 //开启两个session Sessionsession1=sessionFactory.openSession(); Session session2=sessionFactory.openSession(); Student stu1=(Student)session1.createQuery(\"from Student s wheres.name='xiaoming'\").uniqueResult(); Student stu2=(Student)session2.createQuery(\"from Student s wheres.name='xiaoming'\").uniqueResult(); //首先看一下，拿出来的数据的version版本是否一致，结果是是一致，都是数据库当前的版本 System.out.println(\"v1=\"+stu1.getVersion()+\"--v2=\"+stu2.getVersion()); //开始第一个事务 Transactiontx1=session1.beginTransaction(); //修改内容 stu1.setName(\"xiaohong\"); //事务提交 tx1.commit(); //当进行了事务提交之后，也就是数据的更新操作，再看看此时两个version是否一致，结果显示version不一样了 System.out.println(\"v1=\"+stu1.getVersion()+\"--v2=\"+stu2.getVersion()); //同理，再将第二个事务进行提交 Transactiontx2=session2.beginTransaction(); stu2.setName(\"xiaobai\"); //提交 tx2.commit(); OK,编译的时候是没有任何问题的，但是一运行就发现报了一个错，并且错误显示： Exception in thread \"main\" org.hibernate.StaleObjectStateException:Row was updated or deleted by another transaction (or unsaved-value mapping wasincorrect): 其实，原因很简单，就是因为第一个事务提交对数据之后，这条数据的内容被更新，然后数据库中的版本控制字段version相比原来的版本+1，而当第二个事务再提交更新操作的时候，因为当前的数据的版本是原来的版本，而数据库中的版本比它高了，所以就认为这条数据是条无效的数据，那么结果很明显就是会发现刚才的错误。这样的话，是不是对于并发操作的问题就提供了一个很好的方法呢？ Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p004.html":{"url":"hibernate/p004.html","title":"什么是Hibernate的并发机制","keywords":"","body":"什么是Hibernate的并发机制 Hibernate并发机制： Hibernate的Session对象是非线程安全的,对于单个请求,单个会话,单个的工作单元(即单个事务,单个线程),它通常只使用一次, 然后就丢弃。 如果一个Session 实例允许共享的话，那些支持并发运行的,例如Http request,session beans将会导致出现资源争用。 如果在Http Session中有hibernate的Session的话,就可能会出现同步访问Http Session。只要用户足够快的点击浏览器的“刷新”, 就会导致两个并发运行的线程使用同一个Session。 多个事务并发访问同一块资源,可能会引发第一类丢失更新，脏读，幻读，不可重复读，第二类丢失更新一系列的问题。 解决方案：设置事务隔离级别。 Serializable：串行化。隔离级别最高 Repeatable Read：可重复读 Read Committed：已提交数据读 Read Uncommitted：未提交数据读。隔离级别最差 设置锁：乐观锁和悲观锁。 乐观锁：使用版本号或时间戳来检测更新丢失,在的映射中设置 optimistic-lock=”all”可以在没有版本或者时间戳属性映射的情况下实现 版本检查，此时Hibernate将比较一行记录的每个字段的状态 行级悲观锁：Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！只要为JDBC连接指定一下隔 离级别，然后让数据库去搞定一切就够了。类LockMode 定义了Hibernate所需的不同的锁定级别：LockMode.UPGRADE,LockMode.UPGRADE_NOWAIT,LockMode.READ; Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p005.html":{"url":"hibernate/p005.html","title":"update和saveOrUpdate的区别","keywords":"","body":"update和saveOrUpdate的区别 update()和saveOrUpdate()是用来对跨Session的PO进行状态管理的。 update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。 saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会 更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p006.html":{"url":"hibernate/p006.html","title":"Hibernate的三种状态之间如何转换","keywords":"","body":"Hibernate的三种状态之间如何转换 在hibernate中 不同的持久化操作会导致对象的状态的改变 ，如下图所示： 瞬时状态转换为持久状态 使用session对象的save()或saveOrUpdate()方法保存对象后，该对象的状态由瞬时状态转换为持久状态。 使用session对象的get()或load()方法获取对象后，该对象的状态是持久状态。 持久状态转换为瞬时状态 执行session对象的delete()方法后，对象由原来的持久状态变为瞬时状态，因此该对象没有与任何的数据库数据有关联。 持久状态变为游离状态 执行了session对象的evict()、clear()、 close() 方法，对象由原来的持久状态变为游离态。 游离状态转换为持久状态 重新获取session对象，执行session对象的update()或 saveOrUpdate()方法，由游离状态转换为持久状态，该对象再次与session关联。 游离状态转换为瞬时状态 执行session的delete()方法，对象有游离状态变为瞬时状态。 对瞬时状态或游离状态 的对象不再被其他对象引用时，会被Java虚拟机按照垃圾回收机制处理。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p007.html":{"url":"hibernate/p007.html","title":"Hibernate的三种检索策略优缺点","keywords":"","body":"Hibernate的三种检索策略优缺点 立即检索： 优点： 对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象； 缺点： 1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间； 立即检索:lazy=false； 延迟检索： 优点： 由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间； 缺点： 应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化； 延迟加载：lazy=true； 迫切左外连接检索： 优点： 1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少； 缺点： 1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能； 预先抓取： fetch=“join”； Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p008.html":{"url":"hibernate/p008.html","title":"如何在控制台查看Hibernate生成并执行的sql","keywords":"","body":"如何在控制台查看Hibernate生成并执行的sql 在定义数据库和数据库属性的文件applicationConfig.xml里面，把hibernate.show_sql 设置为true 这样生成的SQL就会在控制台出现了。 注意：这样做会加重系统的负担，不利于性能调优。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p009.html":{"url":"hibernate/p009.html","title":"Hibernate都支持哪些缓存策略","keywords":"","body":"Hibernate都支持哪些缓存策略 Read-only: 这种策略适用于那些频繁读取却不会更新的数据，这是目前为止最简单和最有效的缓存策略 Read/write:这种策略适用于需要被更新的数据，比read-only更耗费资源，在非JTA环境下，每个事务需要在session.close和session.disconnect()被调用 Nonstrict read/write: 这种策略不保障两个同时进行的事务会修改同一块数据，这种策略适用于那些经常读取但是极少更新的数据 Transactional: 这种策略是完全事务化得缓存策略，可以用在JTA环境下 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p010.html":{"url":"hibernate/p010.html","title":"sorted collection 和ordered collection的区别","keywords":"","body":"sorted collection 和ordered collection的区别 sorted collection 是在内存中通过Java比较器进行排序的 ordered collection 是在数据库中通过order by进行排序的 对于比较大的数据集，为了避免在内存中对它们进行排序而出现 Java中的OutOfMemoryError，最好使用ordered collection。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p011.html":{"url":"hibernate/p011.html","title":"Hibernate工作原理及为什么要使用","keywords":"","body":"Hibernate工作原理及为什么要使用 工作原理： 读取并解析配置文件 读取并解析映射信息，创建SessionFactory 打开Sesssion 创建事务Transation 持久化操作 提交事务 关闭Session 关闭SesstionFactory 为什么要使用： 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作。 Hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 Hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p012.html":{"url":"hibernate/p012.html","title":"Hibernate是如何延迟加载","keywords":"","body":"Hibernate是如何延迟加载 当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p013.html":{"url":"hibernate/p013.html","title":"说下Hibernate的缓存机制","keywords":"","body":"说下Hibernate的缓存机制 一级缓存： Hibenate中一级缓存，也叫做session的缓存，它可以在session范围内减少数据库的访问次数！ 只在session范围有效！ Session关闭，一级缓存失效！ 只要是持久化对象状态的，都受Session管理，也就是说，都会在Session缓存中！ Session的缓存由hibernate维护，用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。 二级缓存： 二级缓存是基于应用程序的缓存，所有的Session都可以使用。 Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可； 不想用，直接移除，不影响代码。 如果用户觉得hibernate提供的框架框架不好用，自己可以换其他的缓存框架或自己实现缓存框架都可以。 Hibernate二级缓存：存储的是常用的类。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p014.html":{"url":"hibernate/p014.html","title":"Hibernate的查询方式有几种","keywords":"","body":"Hibernate的查询方式有几种 对象导航查询(objectcomposition) HQL查询 1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数 Criteria 查询 SQLQuery本地SQL查询 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p015.html":{"url":"hibernate/p015.html","title":"如何优化Hibernate","keywords":"","body":"如何优化Hibernate 数据库设计调整 HQL优化 API的正确使用(如根据不同的业务类型选用不同的集合及查询API) 主配置参数(日志，查询缓存，fetch_size, batch_size等) 映射文件优化(ID生成策略，二级缓存，延迟加载，关联优化) 一级缓存的管理 针对二级缓存，还有许多特有的策略 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p016.html":{"url":"hibernate/p016.html","title":"谈谈Hibernate中inverse的作用","keywords":"","body":"谈谈Hibernate中inverse的作用 inverse属性默认是false,就是说关系的两端都来维护关系。 比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp) 如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。 如果表之间的关联关系是“一对多”的话，那么inverse只能在“一”的一方来配置！ Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p017.html":{"url":"hibernate/p017.html","title":"Detached Object（游离对象）有什么好处","keywords":"","body":"Detached Object（游离对象）有什么好处 Detached Object（游离对象）可以传递到任何层直到表现层而不是用任何DTO(DataTransfer Objects)。 然后你还可以重新把游离对象赋给另外一个Session。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p018.html":{"url":"hibernate/p018.html","title":"数据库中条件查询速度很慢时如何优化","keywords":"","body":"数据库中条件查询速度很慢时如何优化 建索引 减少表之间的关联 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引，把数据量大的表排在前面 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p019.html":{"url":"hibernate/p019.html","title":"什么是SessionFactory，它是线程安全么","keywords":"","body":"什么是SessionFactory，它是线程安全么 SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问。 一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存. Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p020.html":{"url":"hibernate/p020.html","title":"Hibernate的五个核心接口","keywords":"","body":"Hibernate的五个核心接口 Configuration 接口：配置Hibernate，根据其启动hibernate，创建 SessionFactory 对象； SessionFactory 接口：初始化Hibernate，充当数据存储源的代理，创建session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级、二级缓存； Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的， 避免多个线程共享同一个session，是轻量级、一级缓存； Transaction 接口：管理事务； Query 和Criteria 接口：执行数据库的查询。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p021.html":{"url":"hibernate/p021.html","title":"get和load区别","keywords":"","body":"get和load区别 get()：立即查询 load()：懒加载 get如果没有找到会返回null， load如果没有找到会抛出异常。 get会先查一级缓存， 再查二级缓存，然后查数据库；load会先查一级缓存，如果没有找到，就创建代理对象， 等需要的时候去查询二级缓存和数据库。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p022.html":{"url":"hibernate/p022.html","title":"merge的含义","keywords":"","body":"merge的含义 如果session中存在相同持久化标识(identifier)的实例，用用户给出的对象的状态覆盖旧有的持久实例 如果session没有相应的持久实例，则尝试从数据库中加载，或创建新的持久化实例,最后返回该持久实例 用户给出的这个对象没有被关联到session上，它依旧是脱管的 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p023.html":{"url":"hibernate/p023.html","title":"persist和save的区别","keywords":"","body":"persist和save的区别 persist不保证立即执行，可能要等到flush； persist不更新缓存； save, 把一个瞬态的实例持久化标识符，及时的产生,它要返回标识符，所以它会立即执行Sql insert 使用 save() 方法保存持久化对象时，该方法返回该持久化对象的标识属性值(即对应记录的主键值)； 使用 persist() 方法来保存持久化对象时，该方法没有任何返回值。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p024.html":{"url":"hibernate/p024.html","title":"主键生成策略有哪些","keywords":"","body":"主键生成策略有哪些 主键类型 自然主键（主键本身就是表中的一个字段，实体中一个具体的属性） 表中已经具有某字段，并且该字段具有业务含义作为主键，称之为自然主键。 例如：在person表中的身份证号，既是唯一的，又可以单独标识一个person。 又如：在customer表中，如果把name作为主键，其前提条件必须是，每一个客户的姓名不允许为null，不允许客户重名，并且不允许修改客户姓名。尽管这也是可行的，但是不能满足不断变化的业务需求，一旦出现了允许客户重名的业务需求，就必须修改数据模型，重新定义表的主键，这给数据库的维护增加了难度。 代理主键（主键不是实体中某个具体的属性，而是一个不相关的字段） 表中原本不存在的字段，且不具备业务含义的字段作为主键，称之为代理主键。更合理的方式是使用代理主键。 主键生成策略 主键生成策略，就是每条记录录入时，主键的生成规则。Hibernate中，提供了几个内置的主键生成策略，其常用主键生成策略的名称和描述如下 代理主键 identity（主键自增） 适用于long、short或int类型主键，采用底层数据库本身提供的主键生成标识符。在DB2、MySQL、MS SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增类型。Oracle没有自动增长 sequence（序列） 适用于long、short或int类型主键，Hibernate根据底层数据库序列生成标识符。条件是数据库支持序列。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence，MySQL这种不支持sequence increment（主键自增，单线程，maxID+1） 适用于long、short或int类型主键，由Hibernate提供自动递增的方式生成唯一标识符，每次增量为1。只有当没有其他进程向同一张表中插入数据时才可以使用，不能再多线程环境下使用 hilo（主键自增，高低位算法） hilo（高低位方式high low）是hibernate中最常用的一种生成方式，需要一张额外的表保存hi的值。保存hi值的表至少有一条记录（只与第一条记录有关），否则会出现错误。跨数据库，hilo算法生成的标志只能在一个数据库中保证唯一 native（hilo+identity+sequence三选一） 根据底层数据库对自动生成标识符的能力来选择i dentity、sequence、hilo三种生成器中的一种，适合跨数据库平台开发 uuid（随机字符串作主键） Hibernate采用128位的UUID算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32位的十六进制字符串。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字 uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。 guid（全球唯一标识符） 全球唯一标识符，也称作 UUID，是一个128位长的数字，用16进制表示。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。 Hibernate在维护主键时，先查询数据库，获得一个uuid字符串，该字符串就是主键值，该值唯一，缺点长度较大，支持数据库有限，优点同uuid，跨数据库，但是仍然需要访问数据库。注意：长度因数据库不同而不同。 需要数据库支持查询uuid，生成时需要查询数据库，效率没有uuid高，推荐使用uuid。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p025.html":{"url":"hibernate/p025.html","title":"getCurrentSession和openSession的区别","keywords":"","body":"getCurrentSession和openSession的区别 getCurrentSession会绑定当前线程，而openSession不会，因为我们把hibernate交给我们的spring来管理之后，我们是有事务配置，这个有事务的线程就会绑定当前的工厂里面的每一个session，而openSession是创建一个新session。 getCurrentSession事务是有spring来控制的，而openSession需要我们手动开启和手动提交事务。 getCurrentSession是不需要我们手动关闭的，因为工厂会自己管理，而openSession需要我们手动关闭。 而getCurrentSession需要我们手动设置绑定事务的机制，有三种设置方式，jdbc本地的Thread、JTA、第三种是spring提供的事务管理机制org.springframework.orm.hibernate4.SpringSessionContext，而且srping默认使用该种事务管理机制。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p026.html":{"url":"hibernate/p026.html","title":"Hibernate中的命名SQL查询指的是什么","keywords":"","body":"Hibernate中的命名SQL查询指的是什么 命名查询指的是用标签在影射文档中定义的SQL查询，可以通过使用Session.getNamedQuery()方法对它进行调用。命名查询使你可以使用你所指定的一个名字拿到某个特定的查询。 Hibernate中的命名查询可以使用注解来定义，也可以使用我前面提到的xml影射问句来定义。在Hibernate中，@NameQuery用来定义单个的命名查询，@NameQueries用来定义多个命名查询。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p027.html":{"url":"hibernate/p027.html","title":"为什么在Hibernate的实体类中要提供一个无参数的构造器","keywords":"","body":"为什么在Hibernate的实体类中要提供一个无参数的构造器 每个Hibernate实体类必须包含一个 无参数的构造器, 这是因为Hibernate框架要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例。如果在实体类中找不到无参数的构造器，这个方法就会抛出一个InstantiationException异常。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p028.html":{"url":"hibernate/p028.html","title":"可不可以将Hibernate的实体类定义为final类","keywords":"","body":"可不可以将Hibernate的实体类定义为final类 可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了， 如此一来就限制了使用可以提升性能的手段。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"hibernate/p029.html":{"url":"hibernate/p029.html","title":"Hibernate的OpenSessionView问题","keywords":"","body":"Hibernate的OpenSessionView问题 用于解决懒加载异常, 主要功能就是把 Hibernate Session 和一个请求的线程绑定在一起, 直到页面完整输出, 这样就可以保证页面读取数据的时候 Session 一直是开启的状态, 如果去获取延迟加载对象也不会报错。 问题: 如果在业务处理阶段大批量处理数据, 有可能导致一级缓存里的对象占用内存过多导致内存溢出, 另外一个是连接问题: Session 和数据库 Connection 是绑定在一起的, 如果业务处理缓慢也会导致数据库连接得不到及时的释放, 造成连接池连接不够. 所以在并发量较大的项目中不建议使用此种方式, 可以考虑使用迫切左外连接 (LEFT OUTER JOIN FETCH) 或手工对关联的对象进行初始化。 配置 Filter 的时候要放在 Struts2 过滤器的前面, 因为它要页面完全显示完后再退出。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "},"spring/p001.html":{"url":"spring/p001.html","title":"什么是 Spring 框架？Spring 框架有哪些主要模块？","keywords":"","body":"什么是 Spring 框架？Spring 框架有哪些主要模块？ Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。目的：解决企业应用开发的复杂性。功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能。范围：任何Java应用Spring是一个轻量级控制反转(IOC)和面向切面(AOP)的容器框架。 Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 Everything you need to prepare for your technical interview.modified at 2019-01-18 "},"spring/p002.html":{"url":"spring/p002.html","title":"使用 Spring 框架能带来哪些好处？","keywords":"","body":"使用 Spring 框架能带来哪些好处？ 下面列举了一些使用 Spring 框架带来的主要好处： Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。 与 EJB 容器相比较，IOC 容器更加趋向于轻量级。这样一来 IOC 容器在有限的内存和 CPU资源的情况下进行应用程序的开发和发布就变得十分有利。 Spring 并没有闭门造车，Spring 利用了已有的技术比如 ORM 框架、logging 框架、J2EE、Quartz 和 JDK Timer，以及其他视图技术。 Spring 框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。 要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。 Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。 Spring 提供了一个便捷的事务管理接口，适用于小型的本地事务处理（比如在单 DB 的环境下）和复杂的共同事务处理（比如利用 JTA 的复杂 DB 环境）。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p003.html":{"url":"spring/p003.html","title":"什么是控制反转(IOC)？什么是依赖注入？","keywords":"","body":"什么是控制反转(IOC)？什么是依赖注入？ 控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p004.html":{"url":"spring/p004.html","title":"请解释下 Spring 框架中的 IOC？","keywords":"","body":"请解释下 Spring 框架中的 IOC？ Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了Spring 框架 IOC 容器的基础。BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的WebApplicationContext。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p005.html":{"url":"spring/p005.html","title":"BeanFactory 和 ApplicationContext 有什么区别？","keywords":"","body":"BeanFactory 和 ApplicationContext 有什么区别？ BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。 BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。 提供了支持国际化的文本消息 统一的资源文件读取方式 已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。 ApplicationContext context = new ClassPathXmlApplicationContext(“application.xml”); FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 ApplicationContext context = new FileSystemXmlApplicationContext(“application.xml”); XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p006.html":{"url":"spring/p006.html","title":"Spring 提供几种配置方式来设置元数据？","keywords":"","body":"Spring 提供几种配置方式来设置元数据？ 将 Spring 配置到应用开发中有以下三种方式： 基于 XML 的配置 基于注解的配置 基于 Java 的配置 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p007.html":{"url":"spring/p007.html","title":"如何使用 XML 配置的方式配置 Spring？","keywords":"","body":"如何使用 XML 配置的方式配置 Spring？ 在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的 Spring 配置类型（比如声明的方式或基于 Java Class 的配置方式）Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 下面这个 web.xml 仅仅配置了 DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。 Archetype Created Web Application spring org.springframework.web.servlet.DispatcherServlet 1 spring / Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p008.html":{"url":"spring/p008.html","title":"如何用基于 Java 配置的方式配置 Spring？","keywords":"","body":"如何用基于 Java 配置的方式配置 Spring？ Spring 对 Java 配置的支持是由@Configuration 注解和@Bean 注解来实现的。由@Bean 注解的方法将会实例化、配置和初始化一个新对象，这个对象将由 Spring 的 IOC 容器来管理。@Bean 声明所起到的作用与 元素类似。被@Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被@Configuration 声明的类可以通过在同一个类的内部调用@bean 方法来设置嵌入 bean 的依赖关系。 最简单的@Configuration 声明类请参考下面的代码： @Configuration public class AppConfig{ @Bean public MyService myService() { return new MyServiceImpl(); } } 对于上面的@Beans 配置文件相同的 XML 配置文件如下： 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化 public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff(); } 要使用组件组建扫描，仅需用@Configuration 进行注解即可： @Configuration @ComponentScan(basePackages = \"com.gupaoedu\") public class AppConfig { } 在上面的例子中，com.gupaoedu 包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照 Sring bean 定义进行注册。如 果 你 要 在 你 的 web 应 用 开 发 中 选 用 上 述 的 配 置 的 方 式 的 话 ， 需 要 用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置 Spring 的Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。 contextClass org.springframework.web.context.support.AnnotationConfigWebApplicationContext contextConfigLocation com.gupaoedu.AppConfig org.springframework.web.context.ContextLoaderListener dispatcher org.springframework.web.servlet.DispatcherServlet contextClass org.springframework.web.context.support.AnnotationConfigWebApplicationContext contextConfigLocation com.gupaoedu.web.MVCConfig dispatcher /web/* Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p009.html":{"url":"spring/p009.html","title":"怎样用注解的方式配置 Spring？","keywords":"","body":"怎样用注解的方式配置 Spring？ Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML方式的 bean 描述，可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 在标签配置完成以后，就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。下面是几种比较重要的注解类型： @Required：该注解应用于设值方法。 @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 @Qualifier：该注解和@Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 JSR-250 Annotations ：Spring 支持 基于 JSR-250 注解 的以下 注解 ，@Resource、@PostConstruct 和 @PreDestroy。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p010.html":{"url":"spring/p010.html","title":"请解释 Spring Bean 的生命周期？","keywords":"","body":"请解释 Spring Bean 的生命周期？ Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean容器中移除。Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。 初始化之后调用的回调方法。 销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init()方法和 destroy()方法 @PostConstruct 和@PreDestroy 注解方式 使用 customInit()和 customDestroy()方法管理 bean 生命周期的代码样例如下： Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p011.html":{"url":"spring/p011.html","title":"Spring Bean 作用域之间的区别？","keywords":"","body":"Spring Bean 作用域之间的区别？ Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下： singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。 prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。 request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。 Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。 global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p012.html":{"url":"spring/p012.html","title":"什么是 Spring inner beans？","keywords":"","body":"什么是 Spring inner beans？ 在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。内部 bean 可以用 setter 注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例，然后在 Customer 内部使用。 public class Customer{ private Person person; //Setters and Getters } public class Person{ private String name; private String address; private int age; //Setters and Getters } 内部 bean 的声明方式如下： Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p013.html":{"url":"spring/p013.html","title":"Spring 框架中的单例 Beans 是线程安全的么？","keywords":"","body":"Spring 框架中的单例 Beans 是线程安全的么？ Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p014.html":{"url":"spring/p014.html","title":"请举例说明如何在 Spring 中注入一个 Java 集合？","keywords":"","body":"请举例说明如何在 Spring 中注入一个 Java 集合？ Spring 提供了以下四种集合类的配置元素： 该标签用来装配可重复的 list 值。 该标签用来装配没有重复的 set 值。 该标签可用来注入键和值可以为任何类型的键值对。 该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： INDIA Pakistan USA UK INDIA Pakistan USA UK admin@gupaoedu.com support@gupaoedu.com Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p015.html":{"url":"spring/p015.html","title":"如何向 Spring Bean 中注入 java.util.Properties？","keywords":"","body":"如何向 Spring Bean 中注入 java.util.Properties？ 第一种方法是使用如下面代码所示的 标签： admin@gupaoedu.com support@gupaoedu.com 也可用”util:”命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter方法注入 bean 的引用。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p016.html":{"url":"spring/p016.html","title":"请解释 Spring Bean 的自动装配？","keywords":"","body":"请解释 Spring Bean 的自动装配？ 在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配： 除了 bean 配置文件中提供的自动装配模式，还可以使用@Autowired 注解来自动装配指定的bean。在使用@Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。 也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 配置好以后就可以使用@Autowired 来标注了。 @Autowired public EmployeeDAOImpl ( EmployeeManager manager ) { this.manager = manager; } Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p017.html":{"url":"spring/p017.html","title":"请解释各种自动装配模式的区别？","keywords":"","body":"请解释各种自动装配模式的区别？ 在 Spring 框架中共有 5 种自动装配，让我们逐一分析。 no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean定义中用标签明确的设置依赖关系。 byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。 autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byTpe 的自动装配方式。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p018.html":{"url":"spring/p018.html","title":"如何开启基于注解的自动装配？","keywords":"","body":"如何开启基于注解的自动装配？ 要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 引入配置文件中的下引入 在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p019.html":{"url":"spring/p019.html","title":"自动装配有哪些局限性？","keywords":"","body":"自动装配有哪些局限性？ 自动装配有如下局限性： 重写：你仍然需要使用 和设置指明依赖，这意味着总要重写自动装配。 原生数据类型：你不能自动装配简单的属性，如原生类型、字符串和类。 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p020.html":{"url":"spring/p020.html","title":"在 Spring 中可以注入 null 或空字符串吗？","keywords":"","body":"在 Spring 中可以注入 null 或空字符串吗？ 完全可以。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p021.html":{"url":"spring/p021.html","title":"请举例解释@Required Annotation？","keywords":"","body":"请举例解释@Required Annotation？ 在产品级别的应用中，IOC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置“dependency-check”来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正 确 配 置 。 或 者 你 宁 可 验 证 某 个 bean 的 特 定 属 性 是 否 被 正 确 的 设 置 。 即 使 是 用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。需要用如下的方式使用来标明 bean 的设值方法。 public class EmployeeFactoryBean extends AbstractFactoryBean { private String designation; public String getDesignation() { return designation; } @Required public void setDesignation(String designation) { this.designation = designation; } } RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被@Required 注解的 bean 属性是否被正确的设置了。在使用 RequiredAnnotationBeanPostProcesso 来验证bean 属性之前，首先要在 IOC 容器中对其进行注册： 但 是 如 果 没 有 属 性 被 用 @Required 注 解 过 的 话 ， 后 置 处 理 器 会 抛 出 一 个BeanInitializationException 异常。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p022.html":{"url":"spring/p022.html","title":"请举例解释@Autowired 注解？","keywords":"","body":"请举例解释@Autowired 注解？ @Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像@Required 注解、构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。比如，可以在设值方法上使@Autowired 注解来替代配置文件中的 元素。当 Spring 容器在setter 方法上找到@Autowired 注解时，会尝试用 byType 自动装配。当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 public class TextEditor { private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker){ System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; } public void spellCheck(){ spellChecker.checkSpelling(); } } 下面是没有构造参数的配置方式： Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p023.html":{"url":"spring/p023.html","title":"请举例说明@Qualifier 注解？","keywords":"","body":"请举例说明@Qualifier 注解？ @Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 public class Customer{ @Autowired private Person person; } 下面我们要在配置文件中来配置 Person 类。 Spring 会知道要自动装配哪个 person bean 么？不会的，但是运行上面的示例时，会抛出下面的异常： Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.gupaoedu.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： public class Customer{ @Autowired @Qualifier(\"personA\") private Person person; } Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p024.html":{"url":"spring/p024.html","title":"构造方法注入和设值注入有什么区别？","keywords":"","body":"构造方法注入和设值注入有什么区别？ 请注意以下明显的区别： 在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException 异常，因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p025.html":{"url":"spring/p025.html","title":"Spring 框架中有哪些不同类型的事件？","keywords":"","body":"Spring 框架中有哪些不同类型的事件？ Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件，如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 public class AllApplicationEventListener implements ApplicationListener { @Override public void onApplicationEvent(ApplicationEvent applicationEvent) { //process event } } Spring 提供了以下 5 中标准的事件： 上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。 上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的 Start()方法开始/重新开始容器时触发该事件。 上下文停止事件（ContextStoppedEvent）：当容器调ConfigurableApplicationContext的 Stop()方法停止容器时触发该事件。 上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。 请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请（request）结束触发该事件。除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 public class CustomApplicationEvent extends ApplicationEvent{ public CustomApplicationEvent ( Object source, final String msg ){ super(source); System.out.println(\"Created a Custom event\"); } } 为了监听这个事件，还需要创建一个监听器： public class CustomEventListener implements ApplicationListener { @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) { //handle event } } 之后通过 applicationContext 接口的 publishEvent()方法来发布自定义事件。 CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext,“Test message”); applicationContext.publishEvent(customEvent); Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p026.html":{"url":"spring/p026.html","title":"FileSystemResource 和 ClassPathResource 有何区别？","keywords":"","body":"FileSystemResource 和 ClassPathResource 有何区别？ 在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把ClassPathResource 文件放在 ClassPath 下。如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src文件夹是默认。简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p027.html":{"url":"spring/p027.html","title":"Spring 框架中都用到了哪些设计模式？","keywords":"","body":"Spring 框架中都用到了哪些设计模式？ Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 代理模式—在 AOP 和 remoting 中被用的比较多。 单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。 模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 委派模式：Srping 提供了 DispatcherServlet 来对请求进行分发。 工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext接口的核心理念。 代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p028.html":{"url":"spring/p028.html","title":"在 Spring 框架中如何更有效的使用 JDBC？","keywords":"","body":"在 Spring 框架中如何更有效的使用 JDBC？ 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate。 Everything you need to prepare for your technical interview.modified at 2019-01-22 "},"spring/p029.html":{"url":"spring/p029.html","title":"Spring5 新特性","keywords":"","body":"Spring5 新特性 依赖 JDK 8+和 Java EE7+以上版本 首次采用反应式编程模型 支持使用注解进行编程 新增函数式编程 支持使用 REST 断点执行反应式编程 支持 HTTP 2.0 新增 Kotlin 和 Spring WebFlux 可使用 Lambda 表达式注册 Bean Spring WebMVC 支持最新的 API 使用 JUnit5 执行条件和并发测试 使用 Spring WebFlux 执行集成测试 核心容器优化 Everything you need to prepare for your technical interview.modified at 2019-01-22 "}}